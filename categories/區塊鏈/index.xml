<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🪙 區塊鏈 on Archie</title><link>https://www.archie.tw/categories/%E5%8D%80%E5%A1%8A%E9%8F%88/</link><description>Recent content in 🪙 區塊鏈 on Archie</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.archie.tw/categories/%E5%8D%80%E5%A1%8A%E9%8F%88/index.xml" rel="self" type="application/rss+xml"/><item><title>為什麼我的錢包會被盜？</title><link>https://www.archie.tw/p/%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E7%9A%84%E9%8C%A2%E5%8C%85%E6%9C%83%E8%A2%AB%E7%9B%9C/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E7%82%BA%E4%BB%80%E9%BA%BC%E6%88%91%E7%9A%84%E9%8C%A2%E5%8C%85%E6%9C%83%E8%A2%AB%E7%9B%9C/</guid><description>現實世界的被盜 在現實世界中，要盜走別人的錢財其中一個選項便是偷走別人的錢包；裡頭存放著現金（法定貨幣），交易使用上一般人也不會去檢查鈔票上的序號是不是你本人的，於是乎當你錢包掉了，等同於不肖份子可以拿你的錢財去做任何交易而不會受到限制。
網路世界的被盜 而在網路的普及下，大部分人逐漸地將大部分的法定貨幣轉移到各家銀行帳戶之中，你可以透過卡片（信用卡、提款卡）或是帳號密碼來取回、使用現金。這時，不肖份子的算盤則要往虛擬的事物打去，如騙你自己執行一筆交易（轉帳、領錢出來到指定地點）或是盜刷（偷走信用卡刷小額）甚至是盜用你的網銀帳號密碼。在這個階段，除了要確保自己的錢包沒有亂丟以外，還得開始防範自己的帳號密碼是否有被外流的風險。
Web3 世界的被盜 進入到 Web3 的世界，被盜用的方式其實和網路世界的大同小異
詐騙：騙你自己執行一筆交易 轉帳到指定地址（帳戶） 這種的詐騙在 Web3 比較難發生，一來是大多數擁有虛擬貨幣錢包的人並非不會使用網路的人，故這種最低級的詐騙是較難騙到他人錢財的。
釣魚網站 反倒是釣魚網站的災情就嚴重上許多，對方會做一個假的網站上頭給予各種利益，來誤導你點擊「確認」按鈕來進行一筆交易。這件事在 Web3 的世界之所以更為常見的原因如下
一般人不會認真看簽章內容 區塊鏈上的交易明細和網銀的交易明細有著截然不同的格式，甚至對方可以透過非單純轉帳（transfer）的方式來取得你的虛擬貨幣，如取得授權（setApproval）等。
一般人不會看智能合約內容 更用心一些的不肖份子會部署一份智能合約（以下簡稱合約），包裝轉移的名目讓你以為你要得到利益，但實際上是轉走你的錢財。這個就有點像是簽署了一份贈與協議書，但實際上是你個人的賣身契。
因貪心而大幅降低了警戒心 多數被詐騙的都是一時貪心，隨著釣魚網站上的時間倒數逐漸逼近所營造的 FOMO（Fear Of Missing Out），深怕自己上不了車也忽略了所有細節。
盜用：把你的註記詞 / 私鑰偷走 這邊就要開始循序漸進地來解釋，為什麼私鑰被盜走會造成你的虛擬貨幣損失。
錢包地址是如何來的？ 這邊我們拿以太坊當作例子：
註記詞（Mnemonic）-&amp;gt; 私鑰（private keys） 通常在建立錢包的時候，我們都會得到一組註記詞（12、24 個有順序的單字），而這組註記詞透過加密的方式，可以產生出無限多組私鑰（private keys），不過這個排序都是固定的，所以大多數的錢包應用程式都是顯示第一組私鑰。
私鑰（private key）-&amp;gt; 公鑰（public key） 我們選定一組 private key 後，透過橢圓曲線加密後可以得到一組公鑰。
公鑰（public key）- hash -&amp;gt; 地址（address） 接著拿公鑰進行 hash（Keccak-256）並取結果的最後 20 位當作以太坊地址。
交易是怎麼來的？ 以簡單來說，便是你把打算做的事照格式寫好後，使用 private key 進行簽署會得到一個 signature，而在驗證交易是否成立時，會照以下步驟檢查：
拿 signature 還原訊息 若成功的話，可以得到一組 address 比對 address 是否相同 所以只要拿得到你的註記詞 = 拿得到私鑰 = 拿得到公鑰 = 拿得到地址 = 可以進行交易。</description></item><item><title>Get ETH balance and tokens balance</title><link>https://www.archie.tw/p/get-eth-balance-and-tokens-balance/</link><pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/get-eth-balance-and-tokens-balance/</guid><description>前言 最近都在處理區塊鏈相關的問題，其中一個就是怎麼直接透過節點（****.infura.io）來取得 ETH 和其他 ERC-20 的地址餘額（balance）。
JSON RPC ETH 節點所使用的 request body 是依照 JSON RPC 的方式，也就是我們所使用的 request path 都是相同的，像是主要的 https://mainnet.infura.io ；不同的是，我們可以透過不同的 body 內容來區別不同的需求。
基本的 body 格式 { &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;method name&amp;#34;, &amp;#34;params&amp;#34;: [], &amp;#34;id&amp;#34;: 1 } 取得 ETH 餘額 取得 ETH 餘額的方式較為單純，節點有提供一個 method 是 eth_getBalance，使用起來如下
{ &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;eth_getBalance&amp;#34;, &amp;#34;params&amp;#34;: [&amp;#34;你的 ETH 地址&amp;#34;, &amp;#34;latest&amp;#34;], &amp;#34;id&amp;#34;: 1 } 其中這邊的 latest 意思是指向最新的那個區塊取資料的意思；
我們便可以得到 response：
{ &amp;#34;id&amp;#34;:1, &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;result&amp;#34;: &amp;#34;0x0234c8a3397aab58&amp;#34; // 158972490234375000 } 其中注意到一點是，result 所回應的是你這個地址有幾聰的 hex 字串，所以當我們取得的時候得注意一下。</description></item><item><title>BIP-39 Mnemonic validate</title><link>https://www.archie.tw/p/bip-39-mnemonic-validate/</link><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/bip-39-mnemonic-validate/</guid><description>前言 最近處理了一些加密貨幣的問題，其中一個是助記詞的驗證，這邊將會解釋助記詞的生成和驗證方式。
生成助記詞 首先我們這邊所介紹的是助記詞生成方式，先建立一個 128 bytes 的隨機序列，也就是隨機產生 16 個 UInt8 的序列；
主要有分成 128、160、192、224、256 bits（每 32 bits 做為一個區間），而下列會以 128 bits 作為流程解釋。
對隨機序列加密（SHA256） 我們對剛剛所產生的序列做 SHA256 加密，便會得到由 32 個 UInt8 所組成的 Array。
Checksum 用來驗證助記詞是否正確的方式是透過 Checksum 來辨別，而 Checksum 的 size 為序列的長度 / 區間，如我們這邊所提及的 128 / 32 = 4；
意思便是剛剛所加密完的序列，我們取前面 4 bytes 的數值當作 checksum。
產生助記詞 而剛剛的隨機序列（128 bits）加上 4 bits 的 checksum 組成 132 bits，接著我們每 11 bits 作為一個分隔，也就可以得到 132 / 11 = 12 個數字。
而每 11 bits 作為一個分隔的意思也意味著數字的區間落在 0 – 2047 之間，也就是為什麼 12 字的助記詞所支援的單字庫數量為 2048。</description></item></channel></rss>