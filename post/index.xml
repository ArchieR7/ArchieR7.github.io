<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Archie</title><link>https://www.archie.tw/post/</link><description>Recent content in Posts on Archie</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.archie.tw/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Markdown 嵌入 YouTube</title><link>https://www.archie.tw/p/markdown-%E5%B5%8C%E5%85%A5-youtube/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/markdown-%E5%B5%8C%E5%85%A5-youtube/</guid><description>前言 一般來說，我們都可以直接使用 YouTube 的嵌入程式碼來直接加入影片，而今天如果要在 Markdown 裡頭製作這段這程式碼的話，我們可以怎麼做？
嵌入的程式碼 &amp;lt;iframe width=&amp;quot;560&amp;quot; height=&amp;quot;315&amp;quot; src=&amp;quot;https://www.youtube.com/embed/OyCN04p-uS8&amp;quot; title=&amp;quot;YouTube video player&amp;quot; frameborder=&amp;quot;0&amp;quot; allow=&amp;quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&amp;quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt; Markdown 其實就只有一個重點，就是得到影片的 ID；這個你可以從很多地方取得，以線上讀書會 RxSwift 分享來說
首先就是先取得縮圖的 URL，格式為
URL Description https://img.youtube.com/vi/VIDEO_ID/0.jpg Full-size thumbnail https://img.youtube.com/vi/VIDEO_ID/1.jpg Small thumbnail images https://img.youtube.com/vi/VIDEO_ID/2.jpg Small thumbnail images https://img.youtube.com/vi/VIDEO_ID/3.jpg Small thumbnail images https://img.youtube.com/vi/VIDEO_ID/default.jpg Default thumbnail image https://img.youtube.com/vi/VIDEO_ID/hqdefault.jpg High-quality default thumbnail image https://img.</description></item><item><title>發票收集雞 - 自己的發票自己收</title><link>https://www.archie.tw/p/%E7%99%BC%E7%A5%A8%E6%94%B6%E9%9B%86%E9%9B%9E-%E8%87%AA%E5%B7%B1%E7%9A%84%E7%99%BC%E7%A5%A8%E8%87%AA%E5%B7%B1%E6%94%B6/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E7%99%BC%E7%A5%A8%E6%94%B6%E9%9B%86%E9%9B%9E-%E8%87%AA%E5%B7%B1%E7%9A%84%E7%99%BC%E7%A5%A8%E8%87%AA%E5%B7%B1%E6%94%B6/</guid><description>發票收集雞 八月份開始，我拿著去年年初申請的財政部發票應用 API 來做這個個人專案，其主要的功能都圍繞著雲端發票為主，原因為二
紙本發票的減少 在財政部的推動下，傳統發票的開立已經比以往少去甚多，取而代之的是電子發票和雲端發票。
雲端發票專屬獎 而在推動無紙化的過程中，政府加碼開立雲端發票專屬獎，像是最近一期的總獎金為 5.62 億元（100 萬 30 組、2,000 元 16,000 組、500 元 100 萬組）。所以基本上我自己的話，能存載具就會存載具；而這部分另一個優勢是，可以自動對獎並匯入至指定的帳戶！
基於上述兩個原因，我每兩個月會需要對獎的發票數量銳減至十幾張，而這樣的話，對於我而言也就少了需要人工對獎的功能。
為什麼寫這個 App 主要是以自己的需求出發，來練一些技術，在 SwiftUI 推出後一直都還沒有機會拿來作為一個產品的開發架構，於是便起心動念開工！
使用到了什麼服務和技術 🆕 SwiftUI：嘗試以 Clean architechture 作為架構，而非過往在 UIKit 自己所熟悉的 MVVM Firebase：目前使用到 Auth、Crashlytics、Cloud functions、Storage 和 Firestore CoreData：搭配 CloudKit 作為使用者資料備份的地方 🆕 CloudKit：嘗試使用 CloudKit 來取代其他的 remote database 🆕 Apple Wallet：在 Cloud functions 上寫了一個動態產生 PKPass 的功能並和 app 互動 RevenueCat：作為 In App Purchase 的管理機制 🆕 訂閱制：第一次推出訂閱制的服務，其主要的費用會用來支付上述的一些開銷 發票收集雞的營利方式 廣告 透過一些橫幅和一些功能類型啟動時的插頁廣告作為營利方式。</description></item><item><title>iOS 開發環境設置</title><link>https://www.archie.tw/p/ios-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E8%A8%AD%E7%BD%AE/</guid><description>來算一算這是我第幾次來設置開發環境了⋯
2014 - 買了自己的第一台 MacBook Pro 2015 - 第一份工作所配發的 MacBook Pro 2018 - 換工作所配發的 iMac 2018 - 換工作所配發的 iMac 2020 - 換工作所配發的 iMac 2020 - 向 Apple 所申請的 DTK 2021 - 為了加速開發 side project，買了 MacBook Air M1（正在弄） 前面六次的開發環境設置，都隨著物換星移地不斷迭代；從 bash -&amp;gt; zsh、oh-my-zsh -&amp;gt; zim，加上還因為 DTK 的先行使用，踩了一些當時尚未支援的坑⋯這次再來紀錄一下這過程，讓之後的第八次能夠更順利一些（？
brew 首先，勢必是得從 brew 開始安裝起，也可以簡化後續很多的安裝流程。而這邊主要已經避開了當時還不支援 Apple silicon CPU 的坑，所以十分地順利！
git 自從上次 git 發生了資安問題後，我都習慣用 brew 所安裝的 git 為主。
iTerm2 接著下載 iTerm2 來取代原先的 Terminal，並客製化一下這部分。
刪除的快捷鍵 在 Profiles -&amp;gt; Keys -&amp;gt; Key Mappings 這邊新增兩個</description></item><item><title>Fastlane 503 Service Temporarily Unavailable</title><link>https://www.archie.tw/p/fastlane-503-service-temporarily-unavailable/</link><pubDate>Thu, 01 Jul 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/fastlane-503-service-temporarily-unavailable/</guid><description>Fastlane 503 Service Temporarity Unavaiable 當我們利用 Match 來更新 provisioning profiles 時，有時候會因為使用量過大而導致發生 503 Service Temporarity Unavaiable，這時候有幾種方式來處理。
一次不要操作太多 Match action 清除 fastlane spaceship 的 cookie 第二種的使用方式就是直接執行下列指令就可以再次嘗試了
rm $HOME/.fastlane/spaceship/*/cookie</description></item><item><title>從 Terminal 讓模擬器開啟連結</title><link>https://www.archie.tw/p/%E5%BE%9E-terminal-%E8%AE%93%E6%A8%A1%E6%93%AC%E5%99%A8%E9%96%8B%E5%95%9F%E9%80%A3%E7%B5%90/</link><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%BE%9E-terminal-%E8%AE%93%E6%A8%A1%E6%93%AC%E5%99%A8%E9%96%8B%E5%95%9F%E9%80%A3%E7%B5%90/</guid><description>一般在開發的時候，如果需要在模擬器測試 Deep link 的話，則需要做一個開啟連結的動作；比較手動的就會開啟一個 Safari，輸入特定的連結後前往，而這邊分享一個指令。
xcrun simctl openurl booted &amp;lt;url&amp;gt; xcrun 主要就是執行 Xcode 的一個工具，而 simctl 則是和模擬器的管理工具，而 booted 是指目前開啟著的模擬器。
步驟 打開模擬器 打開任何 Terminal 的 app 輸入上述的指令 這樣模擬器便會開啟連結了！</description></item><item><title>WWDC21 - Platforms State of the Union</title><link>https://www.archie.tw/p/wwdc21-platforms-state-of-the-union/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/wwdc21-platforms-state-of-the-union/</guid><description>Xcode Cloud 一般我們的發佈流程為，從寫程式到測試，接著整合後發佈，再來接著收集資訊後再進行下一輪開發。
Xcode Cloud 將這一切整合在同一個服務之中，讓我們可以直接寫完程式之後，建立 workflow 並整合 Git 服務（GitHub, GitLab 等），接著串接 App Store Connect 進行 TestFlight 和發佈。
我們之後就可以從單一的 Xcode Cloud 介面處理完上述的所有事情，而建立這些 CI/CD 只需要一分鐘的時間。
相比之前弄 GitHub action，應該可以算是更加容易許多（？
建構四步驟 選擇 product 確認 workflow 授權相對應的 source code 連接 App Store Connect 在 CI/CD 的測試以及 Code Review 上的體驗都會比原先使用其他服務上好很多，畢竟是原生的體驗，在 DEMO 影片上看起來都蠻有趣的。
目前可以透過這個連結來註冊 Beta 使用，若有機會的話再來詳細寫一篇這部分的體驗。
Swift concurrency async 和 await 的來臨讓我們能夠取代原先的 completion handler
Completion handler
func prepareForShow(completion: @escaping (Result&amp;lt;Scene, Error&amp;gt;) -&amp;gt; Void) { danceCompany.</description></item><item><title>Magic Keyboard 2 藍牙連接延遲修正</title><link>https://www.archie.tw/p/magic-keyboard-2-%E8%97%8D%E7%89%99%E9%80%A3%E6%8E%A5%E5%BB%B6%E9%81%B2%E4%BF%AE%E6%AD%A3/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/magic-keyboard-2-%E8%97%8D%E7%89%99%E9%80%A3%E6%8E%A5%E5%BB%B6%E9%81%B2%E4%BF%AE%E6%AD%A3/</guid><description>前陣子我的 Magic Keyboard 2 若沒有連接著線，則打字會有延遲的情況；一開始還以為是電腦卡頓的問題，但 Magic Trackpad 卻滑動地很順暢⋯ 便接著線工作了一段時間，直到剛剛決定嘗試修復這問題
以 option + shift 點擊藍牙，我先是「重置藍牙模組」後仍沒有排除延遲的問題，後來選擇了「將所有連接的 Apple 裝置重置為出廠值」， 之後便一切恢復正常了！</description></item><item><title>設計學習補助計畫</title><link>https://www.archie.tw/p/%E8%A8%AD%E8%A8%88%E5%AD%B8%E7%BF%92%E8%A3%9C%E5%8A%A9%E8%A8%88%E7%95%AB/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E8%A8%AD%E8%A8%88%E5%AD%B8%E7%BF%92%E8%A3%9C%E5%8A%A9%E8%A8%88%E7%95%AB/</guid><description>站在公司的角度來看，學習補助計畫是一個對於勞資雙方都有利的福利措施，不論員工的學習補助是投入在工作技能上或是日常生活的其他技能；如運動健身、廚藝或是音樂上，都能夠有機會使團隊成員在工作之餘學習新知，提升各成員的能力。
而這邊我會以個人的角度，站在公司和員工的立場之間做思考和設計，有興趣的人可以一同分享你目前公司的補助方式或是想法。
成本問題 我從 Yourator 上做了一些查詢，簡單舉四家新創公司的學習補助計畫
公司 金額 CodePro酷博兒童程式創客教育 $2,000 月（$24,000 / 年？） 有物報告 $10,000 / 年 均一平台教育基金會 $5,000 / 年 Surveycake $20,000 / 年 從這四家的金額來看，範圍落在 $5,000 - $24,000 / 年之間，假設有一個年薪 100 萬的員工來申請的話，意味著公司投入了 0.5 - 2.4% / 年的額外支出；而若這件事能夠使這名員工在工作上得到 0.5 - 2.4% 的成長，不論是工作表現或是團隊氣氛等，那在我看來都是一項划算的投資。
其中 Survercake 的方案為補助學費的 50%，代表員工本身在學習這一塊上也得投入一半的費用，這也許是一個不錯的方式，能讓員工更正視學習，畢竟自己也有投入一定的成本。
非工作相關的課程補助 如健身、音樂、廚藝等非工作相關的課程，我先簡單找了幾個課程費用來評估
名稱 費用 丙級廚師證照班 $18,000 大安國民運動中心 $50 / 小時 健身一對一教練課 $1,200 / 次 鋼琴家教 $500 - 1,000 / 小時 工作相關的年度盛會門票價格 名稱 門票金額 Google I/O USD $1,150 WWDC USD $1,599 iPlayground TWD $1,800 Pycon TWD $3,500 IxDA TWD $9,800 MOPCON TWD $800 這邊列出來幾個和我工作比較相關聯的開發 / 設計大會，這類門票除了國外的 Google I/O 和 WWDC 以外，其餘的金額皆算是上述補助方案的範圍之內。</description></item><item><title>Apple Watch App 開發除錯心得</title><link>https://www.archie.tw/p/apple-watch-app-%E9%96%8B%E7%99%BC%E9%99%A4%E9%8C%AF%E5%BF%83%E5%BE%97/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/apple-watch-app-%E9%96%8B%E7%99%BC%E9%99%A4%E9%8C%AF%E5%BF%83%E5%BE%97/</guid><description>前陣子在幫水滴發票加入 Apple Watch 的功能，這篇文章會紀錄下開發的一些想法。
資料傳遞方面 因為 Watch app 本身可以為一個獨立的 app，所以 UserDefaults 的部分則會擁有自己的一份，也就是說兩者之間無法像是 Widget 一般透過同一個 Group 的 UserDefault 來同步資料。
解決方法 利用 WCSession 來做傳遞資料。
實機測試時，WCSession.isReachable 始終為 false 主要就是手機和手錶之間一直無法透過 WCSession 連接上彼此，會造成幾個問題如
Apple Watch App 一直卡在安裝中，無法順利安裝 無法透過 WCSession 從 iOS app 傳遞資料過去給 Watch app 解決方法 我遇到這情況是都選擇重開 iPhone 來處理。
Apple Watch 模擬器和實機上的測試結果不同 在這次的開發之中，我們有使用到比較大的數字在中間傳遞，而原先沒多考慮就以 Int 來存 Timestamp，並在 Apple Watch 的模擬器上測試過幾輪沒出現問題；直到發佈 TestFlight 後才陸續出現在實體裝置上。 進而才意會到模擬器上的 Int 是 64 bit（Int.max = 9223372036854775807），而實際上以 Apple Watch SE6 來說，是 32 bit（Int.</description></item><item><title>新創神秘故事：造假的學經歷背景</title><link>https://www.archie.tw/p/%E6%96%B0%E5%89%B5%E7%A5%9E%E7%A7%98%E6%95%85%E4%BA%8B%E9%80%A0%E5%81%87%E7%9A%84%E5%AD%B8%E7%B6%93%E6%AD%B7%E8%83%8C%E6%99%AF/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E6%96%B0%E5%89%B5%E7%A5%9E%E7%A7%98%E6%95%85%E4%BA%8B%E9%80%A0%E5%81%87%E7%9A%84%E5%AD%B8%E7%B6%93%E6%AD%B7%E8%83%8C%E6%99%AF/</guid><description>新創神秘故事的內容來自親朋好友以及自身經驗，寫出來的宗旨為提供求職者或是在新創圈奮鬥的工程師們一個借鏡，以避免重蹈覆轍。
這些話寫在前面 這故事和 老闆的弟弟 是不同家公司，所以兩者之間並沒有關聯，神秘的地方也有所不同，這次的故事主角並非是 Founder / Co-Founder 的，而是某位神秘的員工。
故事開始 在加入這家公司時，已經有一些成員在裡頭，像是 backend、Android、UI / UX、HR 等，以一個新創團隊來說是相對完整的；不過其中最微妙的就是，在我剛進入的時候，公司有數個負責行銷、市場的實習生，詳細的人數有些忘了，印象中是 5 - 10 個這種數字。
不過我確定的是，工程師包含我只有三人，也就是上述提及的三個工程師職位而已。
這些實習生的 owner，是一位負責行銷和市場驗證的；他將這些實習生分成幾個功能面向，有些負責行銷發想，有些負責市場分析、有些負責調查，而實習生們會定期分享他們的成果。
這件事本身沒什麼問題，問題在於發生的時間點
工程和行銷之間的失衡 剛進去的時候，是預計要做一個新的 app 出來，也就是要做一個 MVP 的意思；而在還沒有產品的時候，公司卻投入了大量的人力和資源去做行銷這一塊，是有些本末倒置的。
而在還沒有產品可以推出的時候，行銷團隊基本上只能做市場的調查和分析，以及使用者訪談等釐清功能的優先順序之類的。
不過事情總是不可能如此順遂，一來是實習生能提供的多數是人力上的協助，產出的分析和調查能力有限、二來是當我們工程團隊的產出能量不及行銷團隊發想的爆炸速度時，多半後續的發想都偏向空想居多；也就是說無法在產品推出後先驗證一下市場，再進行下一步的規劃和分析調查。
那段時間還會時不時地出現一顆顆的隕石砸落在工程團隊上，用新的分析或是功能設計來推翻前一次的結論等，也就加劇了彼此之間的失衡。
這其中一個問題便是在 MVP 並沒有被定義清楚，導致產出上不斷地重新定義許多功能。
這時候不經讓我們思考，為何需要在這麼前期的時候聘用那麼多行銷實習生？
重新調整組織 這時候，上頭的人決定去和負責的同仁討論這部分的問題，不過該同仁十分堅決地表示自己需要這數量的實習生們協助她做這些調查和分析，才能夠好好做事；並開始放招，將過往的經歷一一拿出來來佐證自己的決策是可行的。
這部分其實也沒什麼問題，拿自身經驗來告知團隊決策的依據是什麼
不過她的一些行為開始讓我們有些懷疑，她過往的那些經歷和公司真的會使她能夠做出這種決策嗎？
這時，她提及的這些經歷在其他人的心中產生了一些不確定性，於是我們決定查驗一下。
DD - Due Diligence 在新創圈這個詞應該算是蠻常見的，主要是投資方和被投資方去實際查核對方是的背景和談判的內容是否如實地在運行。
而使用在人身上，便是去查核其履歷上提及的資訊，簡單來說就是徵信社的概念。
這邊就會呼應到一件事，就是其實新創團隊在初期的時候並沒有那麼多資源可以投入在查核履歷這方面；有更多的時間和人力多半都會投資在開發 MVP 之上，而非花時間和精力去查核一個員工的履歷內容是否如其所說的。
多半都會選擇相信對方來降低這部分的成本，除非⋯
選擇繼續相信的潛在成本已經高於查核這件事所需要的成本
開始柯南式的調查 首先，我們從他的學歷開始調查，於是便致電到他履歷上所寫的畢業系所去詢問一下；而這時候得到令人發寒的回訊⋯
該系所的系秘告知，該同學在大學 O 年級的時候，因為一些原因便休學了。
「！」
辦公室氣氛開始陷入一個謎樣的狀態，我自己是有一種莫名的興奮，比較白話的心路歷程大概就是</description></item><item><title>新創神秘故事：老闆的弟弟</title><link>https://www.archie.tw/p/%E6%96%B0%E5%89%B5%E7%A5%9E%E7%A7%98%E6%95%85%E4%BA%8B%E8%80%81%E9%97%86%E7%9A%84%E5%BC%9F%E5%BC%9F/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E6%96%B0%E5%89%B5%E7%A5%9E%E7%A7%98%E6%95%85%E4%BA%8B%E8%80%81%E9%97%86%E7%9A%84%E5%BC%9F%E5%BC%9F/</guid><description>新創神秘故事的內容來自親朋好友以及自身經驗，寫出來的宗旨為提供求職者或是在新創圈奮鬥的工程師們一個借鏡，以避免重蹈覆轍。
故事開始 曾加入過一家新創 / 小公司，公司成員的組成為 CEO、CTO、PM、backend、Android、設計以及我負責 iOS。
在面試的時候，是由 PM 來交辦面試流程，她會給你一個測驗用的專案，裡頭有 3 個 bugs 需要修，修完之後通知她，接著她就會照規格去驗證；從這個面試流程不難想像合作的時候，工作流程就是如此。
這部分我反倒覺得不錯，因為可以在面試的時候就先了解這公司的開發流程。
而這專案的 Xcode 和 Swift 版本都不是最新的，這部分就反應了兩個潛在問題需要釐清
面試的專案並沒有在維護 目前開發的專案本身就是舊版本的 Xcode + Swift 在開發 如果是後者的話，那就是一個蠻細心的面試題。
不過答案是前者。
接著就進到和 CEO 談 offer 的階段，這邊部分的面試給我的感覺還不錯，感覺的到對方是真的有希望你能夠加入；並有提及該職缺向上就是 CTO，且 CTO 人在國外，所以彼此會需要磨合開發的流程。
而 CEO 有提到，他並不會介入我們的開發規劃，所以只要 CTO 做的決策他這邊都可以接受。
這點也是好事，CEO 不會介入開發的時程安排，至少確定隕石流開發的可能降低了一半。
不過恐怖的事情也是如此發生的⋯
報到第一天 我所拿到的開發裝置是一台 iMac，PM 吩咐我說每天下班的時候都要記得關機（？），說這是上頭要求的。 在我對這事情還沒有太多頭緒，只覺得有點問號的時候，打開了這台 iMac 要開始安裝 Xcode 等軟體時發現⋯
我並沒有權限可以直接安裝任何軟體。
PM：「技術長有和我說，如果你有需要安裝什麼軟體的話，列出來他會負責安裝進去。」
意思就是技術長有遠端可以操控這台電腦的權限
我當下就覺得這件事情十分的不妙，於是便要求直接開權限給我，不過這件事被駁回了。
「不然就先來看看工作內容吧⋯」</description></item><item><title>為什麼加入新創公司？</title><link>https://www.archie.tw/p/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%8A%A0%E5%85%A5%E6%96%B0%E5%89%B5%E5%85%AC%E5%8F%B8/</link><pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%8A%A0%E5%85%A5%E6%96%B0%E5%89%B5%E5%85%AC%E5%8F%B8/</guid><description>為什麼加入____公司？ 如果你已經工作一段時間，或者是正打算開始求職的新鮮人，不妨先花個幾分鐘的時間思考一下這問題。
接著，我來回答這個問題
為什麼加入新創公司？ 從幾個層面來分析我在求職上的選擇和考量
學歷 我是名輔仁大學電機工程學系的學士畢業生，在求學期間並沒有額外去修資工的課程，憑著自己在替代役期間對於 iOS 開發的好奇和興趣，而走向了 iOS 工程師的職涯選擇。
對於許多公司而言，我的學歷背景並非能夠吸引到他們，特別是比較有規模的公司。
他們看重新鮮人的學歷，甚至以此為核薪的依據，畢竟拿學歷直接評斷一個人的能力，是一件相對輕鬆的事；他們就可以少花一些心力在了解求職者的想法上，讀書成績不錯，基本上確保了你這個人至少在學科上是有能力的。
於是，在我第一次去參加某上市公司的 Junior iOS 工程師面試時，被要求要帶畢業證書影本（證明真的有大學畢業）和準備成績單這種事，似乎就不怎麼意外了。
「輔大畢業想領 OOK？我們這邊台大畢業生都只有 OOK 了！我這邊只願意開 OOK 給你！」
當下的感覺挺不舒服的（對，就是不爽），便直接婉拒後續的面談離開。
在有了經驗後，我開始刻意地避開要求學歷或本科系的 Junior 職缺，而尋找對於求職者比較 open mind 的職缺內容介紹。
沒有學歷加分的情況下，我在準備面試的策略是個人的 side project，並尋找願意聽我分享開發 side project 心路歷程的公司。
自己當時篩選的條件為
公司文化開放 做產品導向的公司，而非外包 不限本科系學生 而恰好多數的台灣新創都保留類似的特質，也給了我一個真正開始做產品的機會。
新創神秘故事：當公司十分看重學歷時
彈性 多數的新創公司都是責任制，上下班的時間較為彈性；這部分有些人喜歡，有些人反感。
但以我的個性，本來就不適合太制式化的上班環境，像是穿制服、遲到要扣錢之類的，都不是心目中理想的工作環境。
舉凡連假前能夠提早離開來避開車潮、遇到週末補班時選擇放假或是輕鬆的工作模式等，我認為都是新創比一般或是傳產較為願意調整的地方。
上述談的是物理上的彈性，而實際上新創的工作氛圍還需要提供大家思維上的彈性空間，也就是讓多數人能夠且願意表達自己的想法。
新創神秘故事：表面上彈性，背地裏算計
參與產品的程度 在投入到新創的產業中，多半都有更多的機會可以參與到整個產品的開發和設計走向；不會只是單純做一個功能的維護開發或是效能的優化調教。
這部分也是見仁見智，有些人喜歡專研特定的技術並走得深入、有些人喜歡做產品，就得多碰許多不同層面的東西，但就沒那麼多心力可以投入在單一的點上。
而新創團隊人數通常在一開始都不會太多，所以十分容易出現一個人負責一個平台，並需要常常跨平台、跨領域的去和其他人進行溝通討論。
反之，若當公司的發展和產品的規劃，漸漸地都是由有權力的少數人在掌控時，那也就漸漸脫離新創的特質。
新創神秘故事：沒拿薪水的人說的算？
參與公司文化的建立 已經有一定規模的公司，基本上文化的部分是吸引人才加入的原因；而新創的話則是提供你一個可以去影響公司文化的舞台，簡單來說就是你的所作所為都有可能推動或是改變公司特定的風氣。
在這方面上，已經和單純的軟體開發工作有一些落差；在新創裡頭，我們不只需要維護程式碼的品質，甚至是成員間的互動和想像。
特別是越早加入的成員，影響公司的文化風氣越深；所以若有機會進入越早期的團隊，越有機會將團隊文化帶向你所期望的地方去。不過相對的就會越不穩定，個人的風險就會越高。
高風險追求高報酬 新創提供不了大公司的穩定職涯環境，取而代之的是有爆發的潛力；多半的新創團隊在找尋人才時，需要提供相對高的利益條件（股權、薪資、休假福利等）才會越有機會說服對方捨棄大公司的穩定來一搏。</description></item><item><title>RxSwift 6 上線啦！</title><link>https://www.archie.tw/p/rxswift-6-%E4%B8%8A%E7%B7%9A%E5%95%A6/</link><pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/rxswift-6-%E4%B8%8A%E7%B7%9A%E5%95%A6/</guid><description>2021 的開始，RxSwift 6 悄悄地上線啦！你可以從這個網站來看看有哪些更新，或看看這篇筆記📒
這次更新的項目為 新的 logo 將 Binder 從 RxCocoa 移植到 RxSwift RxSwift 新增 withUnretained 透過 @dynamicMemberLookup 來自動建立 Binders Infallible Observable&amp;lt;Data&amp;gt; 新增 decode(type:decoder:) Variadic drive() 和 emit() 將 Single 的結果調整成 Result distinctUntilChange(at:) 支援 Key Paths 新增 ReplayRelay 新增 DisposeBag 的 functional builder 重新命名運算子 新的 logo powered by dev.to
將 Binder 從 RxCocoa 移植到 RxSwift 原本 Binder 是屬於 RxCocoa 裡頭的元件，而在社群大家的討論下，便在這一次的更新內容，將其收納進了 RxSwift 之中。
RxSwift 新增 withUnretained 我們在寫 RxSwift 時，還是得注意 retain cycle 的問題，而多半我們處理的方式如下</description></item><item><title>職缺與履歷的互動 - 以水滴信用為例</title><link>https://www.archie.tw/p/%E8%81%B7%E7%BC%BA%E8%88%87%E5%B1%A5%E6%AD%B7%E7%9A%84%E4%BA%92%E5%8B%95-%E4%BB%A5%E6%B0%B4%E6%BB%B4%E4%BF%A1%E7%94%A8%E7%82%BA%E4%BE%8B/</link><pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E8%81%B7%E7%BC%BA%E8%88%87%E5%B1%A5%E6%AD%B7%E7%9A%84%E4%BA%92%E5%8B%95-%E4%BB%A5%E6%B0%B4%E6%BB%B4%E4%BF%A1%E7%94%A8%E7%82%BA%E4%BE%8B/</guid><description>Credidi Inc.
這篇文章是以我個人的角度來看「職缺與履歷的互動」這件事，並以我目前服務的公司 - 水滴信用在 Yourator 上開的職缺為例。
職缺 在目前所開出的四個職缺當中，我所負責職缺內容為下列兩個
Junior iOS Engineer Senior Android Engineer 所以在這，我能夠負責回答在整理這兩份職缺時的想法。
工作內容 Seniod Android Engineer
Junior iOS Engineer
這一段裡頭，框起來的文字是我所撰寫的；目標是在幾句話內讓求職者大略地了解自己會接觸到怎樣的架構和必要的工具。
基本上不論是 iOS 或是 Android，都是以 MVVM + Rx 作為主要的架構；而 iOS 的部分多了 Coordinator 的使用。
而 iOS 和 Android 這兩份職缺另一個不同的點是，Android 的需求是一位 Senior 的成員；我們期望他 / 她能夠參與前端架構的討論並協助負責其 repository 的 pull requests review 工作。
這部分算是解釋了我們團隊目前所選擇的框架，也一定程度地透露了團隊在技術面上的喜好；以框架而言，我們期望可以找到對 Reactive 有興趣的人進來聊聊，而若你並不怎麼喜歡這技術的話，在投遞履歷前也可以多加評估。
條件要求 Senior Android Engineer
Junior iOS Engineer</description></item><item><title>GitHub Actions + Fastlane + Cache = 👍</title><link>https://www.archie.tw/p/github-actions-fastlane-cache/</link><pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/github-actions-fastlane-cache/</guid><description>這篇文章的內容主要是分享過去這兩天，我在專案上啟用 GitHub Actions 的筆記
GitHub Actions
如上面圖示所言，GitHub 現在也提供了 workflows 讓我們可以在上頭做 CI/CD，而最大的優點就是它本身即掌管程式碼的所在地，所以在 trigger 方面自然會比其他單純做 CI/CD 的服務有一些優勢。
建立方式 首先，你得在你的專案裏頭建立一個 workflows 的資料夾，其路徑得為
/.github/workflows 並在裡頭新增一個 .yml 檔案，來讓 GitHub 讀取。
yml 編輯 name: Workflow name on: workflow_dispatch push: branches: [ master ] pull_request: branches: [ master ] jobs: build: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Setup SSH key run: | mkdir -p ~/.ssh echo &amp;quot;${{ secrets.CERTIFICATE_SSH_KEY }}&amp;quot; &amp;gt;&amp;gt; ~/.ssh/id_rsa echo &amp;quot;${{ secrets.</description></item><item><title>Go 的環境變數使用</title><link>https://www.archie.tw/p/go-%E7%9A%84%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/go-%E7%9A%84%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8%E4%BD%BF%E7%94%A8/</guid><description>在 Go 裡頭，使用環境變數的方式為
import ( &amp;quot;os&amp;quot; ) os.Setenv(&amp;quot;變數名稱&amp;quot;, &amp;quot;變數值&amp;quot;) os.Getenv(&amp;quot;變數名稱&amp;quot;) 而這邊要順帶介紹的是 GoDotEnv
具體使用的方式為
import ( &amp;quot;github.com/joho/godotenv&amp;quot; ) err := godotenv.Load() if err != nil { //something wrong } 這樣就可以去讀專案底下的 .env 檔案，也可以將這份檔案加入到 .gitignore 來忽略上傳，讓我們的程式碼可以開源也不會將自己的私鑰上傳上去。
若不打算處理錯誤的話，可以更改為
import ( _ &amp;quot;github.com/joho/godotenv/autoload&amp;quot; ) 便會在 package init() 的時候就自動 Load()</description></item><item><title>Archie 的斜槓紀錄 2020-03</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-03/</link><pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-03/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense 這個月並沒有上架新的 App，所以數字並沒有上升的趨勢，處在 $ 162.31
Bitfinex 因應疫情，收益有大幅下降的情況，目前一天大概都是在 USD $ 0.6 左右（$ 18.14）
三月份共計 USD$ 36.07，相比上個月的 USD$ 64.31 ，幾乎是腰折等級😭
股利 0050.tw 在 3/6 時發送的股利，我只有買一些些，故得股利 $ 653。
Upwork 在三月份的時候，開始在 Upwork 上找案子做看看，投遞了幾個並得到一個小案子🎉一共獲利 USD$ 40
Apple Connect 透過找飲料的 IAP，獲利了 $ 182
總收入 折合台幣 $ 3,092.42</description></item><item><title>Xcode 11.4 archive issue</title><link>https://www.archie.tw/p/xcode-11.4-archive-issue/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/xcode-11.4-archive-issue/</guid><description>今天使用了 Xcode 11.4 來打包找飲料 1.2.1 版本卻遇上了未知的錯誤， 而這邊就紀錄目前所找到的解法
Xcode 11.4 - Archiving project - Segmentation Fault 11 經實測後無效
Xcode 11.4, error: Segmentation fault: 11 經實測後可以順利打包上傳到 App Store</description></item><item><title>【iOS 逆向】下載 Instagram 動態照片</title><link>https://www.archie.tw/p/ios-%E9%80%86%E5%90%91%E4%B8%8B%E8%BC%89-instagram-%E5%8B%95%E6%85%8B%E7%85%A7%E7%89%87/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-%E9%80%86%E5%90%91%E4%B8%8B%E8%BC%89-instagram-%E5%8B%95%E6%85%8B%E7%85%A7%E7%89%87/</guid><description>這篇文章的起點是從 ZheChgLi 所發表的 iOS 逆向初體驗，我會紀錄自己在 Instagram.app 上的操作流程，並補足一些細節部分。
環境 macOS: 10.15.4 iOS 裝置 iPhone 6 iOS 12.4 （越獄） iPhone X iOS 13.4 Xcode 11.4 我這邊準備了兩個裝置，其中越獄的方式可以參考之前的文章 - Reveal2Loader + iOS 12.4。
連上越獄裝置 流程如同之前所提及的，先開啟 iproxy 來代理 22 port
iproxy 2222 22 並透過 ssh 的方式連上越獄裝置
ssh -p 2222 root@127.0.0.1 密碼預設會是 alpine
提取 .ipa 我照著 medium 上的教學，使用 frida-ios-dump 作為提取的方式。
frida-ios-dump 安裝 首先，先在 iOS 裝置上安裝 Frida
這邊會取決於你的裝置是哪一種 CPU 而不同。</description></item><item><title>iOS App launch time 心得</title><link>https://www.archie.tw/p/ios-app-launch-time-%E5%BF%83%E5%BE%97/</link><pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-app-launch-time-%E5%BF%83%E5%BE%97/</guid><description>如何減少 iOS App launch time 這篇文章就來紀錄一下今日的研究項目，主要的起因是前一篇使用 Xcode 建立一個 Framework有談到如何選擇要創建的是 static library 還是 dynamic framework，其中一個差異是 dyld ( dynamic loader ) 會在 pre main 的時候去載入 dynanmic frameworks，所以若是有越多的 dynamic frameworks 需要載入時，便會花上越多時間。而Apple也建議我們不要使用超過 6 個非系統的 dynamic frameworks。
再來搭配服用 weak self - 25: 難道公司發大財了！？App Launch Time 加速面面觀，一併做一個筆記整理。
App 啟動的三個階段 Pre-main: Loading (MachO + dylib) / Rebase &amp;amp; Binding / ObjC Setup / Initializer 如何查看 pre main time
透過在 Target 的 Environment Variables 加入 DYLD_PRINT_STATISTICS 並設為 1 便可以在 Debug console log 得到資訊。</description></item><item><title>使用 Xcode 建立一個 Framework</title><link>https://www.archie.tw/p/%E4%BD%BF%E7%94%A8-xcode-%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-framework/</link><pubDate>Thu, 26 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E4%BD%BF%E7%94%A8-xcode-%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-framework/</guid><description>之前有介紹過如何建立一個 CocoaPods，而這篇文章則是紀錄一下這次直接在 Xcode 上建立 Framework 會遇上的問題。
建立 Framework 專案 首先我們先打開 Xcode，並選擇 iOS 類別底下的 Framework &amp;amp; Library 裡頭的 Framework
並依照所需要的欄位填寫相關資訊，這邊目前都和直接建立一個專案一致流程。
而如果你有打算在裡頭寫測試的話，就將 Include Unit Tests ☑️
Framework 開發 使用 Xcode 建立起來和 CocoaPods 創建，在開發上並沒有什麼差異；所以就依照著相對應的存取限制來設計你的 framework 即可。
這篇的重點會落在一些參數設定。
Mach-O Type 決定方式 在這個 framework 的 target 之中，我們可以從 Build Settings 的 Mach-O Type 來決定它是一個怎樣的 framework
而要如何取捨這個 framework 的輸出型態，可以依據一些使用方式來判斷
Static Library 有使用到其他 static library 使用 Singleton Dynamic Library 有包含其他檔案，如圖片、JSON 之類的 輸出成 .</description></item><item><title>麥當勞報報 API 分析</title><link>https://www.archie.tw/p/%E9%BA%A5%E7%95%B6%E5%8B%9E%E5%A0%B1%E5%A0%B1-api-%E5%88%86%E6%9E%90/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%BA%A5%E7%95%B6%E5%8B%9E%E5%A0%B1%E5%A0%B1-api-%E5%88%86%E6%9E%90/</guid><description>2020.12.25 目前麥當勞的 API 已經從 Restful 轉成 WebSocket 的形式，所以該篇文章的方式目前是無法實作的。
麥當勞報報簡單來說就是麥當勞的會員 app，你可以每日在上頭得到一些優惠券，不過是採取簽到的方式領取；也就是說如果今天你忘了登入領取的話，隔天也不會變成有兩種優惠可以領取。
麥當勞報報 API 分析 透過一些工具，我們可以得到麥當勞報報的 API 路徑和內容，其中分成三種 base url
https://api.mcddaily.com.tw 從列表來看，我目前有使用到的是這五個 API
分別是
/verify_member_access_token 驗證 access token 是否還有效
/update_attributes 從內容看不太出來是幹嘛用的，不過我想對於我們而言也沒什麼特別的用途
/get_info 從 Response body 來看的話，算是麥當勞報報登入成功後第一支得呼叫的 API； 裡頭含有 member_info 的資訊為主
/logout 使用 access_token 就可以登出了，不過這邊有個問題是登出後 access_token 並不會過期⋯ 也就是就算我已經呼叫過了登出這支 API，但仍然可以使用原先的 access_token 來打其他 API⋯ 也就是可以做別的事，不用怕 token 登出就無效了
/login_by_fb 就是基本的從 Facebook 取得 token 去換麥當勞報報的 access_token 和使用者資料，基本上看起來 response body 和 /get_info 的一模一樣。</description></item><item><title>Archie 的斜槓紀錄 2020-02</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-02/</link><pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-02/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense AdSense 的部分，這個月寫了兩款 App：
找健身
找飲料
所以 AdSense 的部分是上升的，但距離養活自己還是有很巨大的差距啊！
Bitfinex 收益為 US$ 64.31
統一發票兌獎 這個月電子發票中了一張 200 元，不無小補👍
總收入 AdSense $191.36 Bitfinex $1,944 統一發票 $200 $ 2,335</description></item><item><title>使用 API 來讀取 GitHub repository</title><link>https://www.archie.tw/p/%E4%BD%BF%E7%94%A8-api-%E4%BE%86%E8%AE%80%E5%8F%96-github-repository/</link><pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E4%BD%BF%E7%94%A8-api-%E4%BE%86%E8%AE%80%E5%8F%96-github-repository/</guid><description>這篇文章將來介紹一下如何使用 API 來讀取 GitHub repository 上的檔案，而為什麼需要這樣做呢？
因為我專精的是 iOS 啊 以一個 iOS 工程師而言，我們若需要自己維護一個 side project（如 找健身），那我們就得想一些簡單一點的 server 方案；其中一個就是可以將一個 JSON 檔案放到 GitHub 的某個私人 repository 上，並透過 GitHub API 的方式去讀取它，達到 GET 的效果。
這樣便可以有效率地開發 iOS 的部分，而不必花太多心思在維護後端，至少不必煩惱伺服器的費用和穩定😂
流程 取得 API Token 首先我們得先到 GitHub 的設定頁之中，去建立一組 API token
file
選取 Developer settings
file
選擇 Personal access tokens 並建立一組
file
再來依據你的需求選擇 scopes，像是 repo 存取全開
file
接著就會拿到一組 Token！
API 的使用方式 首先我們得在 Headers 加上兩個 KEY-Value</description></item><item><title>💪找健身💪-免綁約單次收費健身房清單</title><link>https://www.archie.tw/p/%E6%89%BE%E5%81%A5%E8%BA%AB-%E5%85%8D%E7%B6%81%E7%B4%84%E5%96%AE%E6%AC%A1%E6%94%B6%E8%B2%BB%E5%81%A5%E8%BA%AB%E6%88%BF%E6%B8%85%E5%96%AE/</link><pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E6%89%BE%E5%81%A5%E8%BA%AB-%E5%85%8D%E7%B6%81%E7%B4%84%E5%96%AE%E6%AC%A1%E6%94%B6%E8%B2%BB%E5%81%A5%E8%BA%AB%E6%88%BF%E6%B8%85%E5%96%AE/</guid><description>近年來健身風氣盛行 許多人會依靠健身來雕塑身形、增強身體機能、增加運動表現 但這些都必須依靠長期的運動習慣來達成
當你過年回家想健身卻找不到健身房 當你出門旅遊想健身卻找不到健身房 當你被派到外縣市出差一個月卻找不到健身房 這些困擾 我們懂
所以我們開發了一款 app 能幫助大家迅速找到最近的、收費最合理的單次收費健身房 只要開啟定位 所有困難就能迎刃而解
另外 app 內也設有使用者回報機制 當你發現有新開的單次收費健身房也歡迎回報 一起完整這個健身網！
iOS 下載點
緣起 在這幾年健身的風氣逐漸熱絡，健身房的類型也越來越多種類；舉凡綁約制、課程型、月費制、單次收費等，健身的產業帶動了相關人才的產出，使得一般大眾接觸健身的門檻降低不少。
撇除一般知名度較大的連鎖會員制健身房，若我們想要在周遭找到一間不用綁約、單次收費的健身房，那麼則需要花上一些時間做功課。於是便在某天發現了扣取港 Coach Duncan的一篇動態，有為這類需求的人做一份清單。 從 2018年7月27日開始並有持續地在更新維護。
而 PTT MuscleBeach 版也有相關文章在討論「單次」這個關鍵字： 於是乎便萌生了整合這類資訊的念頭，進而生出了這個 app
過程紀錄 2020/2/3 萌生這個念頭
2020/2/5 送出第一版（28 家健身房） 2020/2/6 04:21 出現在架上🎉
2020/2/6 15:47 第一次 Side project 站上排行榜📈 第 52 名
2020/2/6 18:22 一度還跑到了前 50 名😂 第 45 名</description></item><item><title>Archie 的斜槓紀錄 2020-01</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-01/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2020-01/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense AdSense 的部分，沒什麼新作品加上文章幾乎兩個都沒在更新，所以收益下滑😭
Bitfinex 1 月份的走勢
由於在前陣子突然一波高漲，目前我的放貸還有幾個高利率檔期中，各放了 30 天的長期
故上個月的收益很讚讚👏來到了 USD$ 58.25
總收入 AdSense $76.56 Bitfinex $1760.84 $ 1837.4</description></item><item><title>Reveal2Loader + iOS 12.4</title><link>https://www.archie.tw/p/reveal2loader-ios-12.4/</link><pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/reveal2loader-ios-12.4/</guid><description>首先先來介紹 Reveal2Loader，它是一款可以在越獄的裝置上讓 Reveal 讀取任何 app 的插件，至於 Reveal 的使用方式就先不在這邊提了。
我們可以透過這個方式來查看別人的 app 是怎麼設計 UI 的，以 Twitter 的 iOS app 為例子
我們可以看到他們所使用的字型、大小、顏色以及元件名稱等，像是這邊就是他們自己定義的 T1StatusAttributedTextView。
越獄 我是使用 iOS 12.4 的 iPhone 6 搭配 unc0ver 來進行越獄，你可以很輕易地使用手機來開啟這個網頁來進行操作，這步驟沒什麼難度。
安裝 Reveal2Loader 透過 Cydia 來安裝 Reveal2Loader，如果安裝的時候出現了找不到來源的錯誤時，可以重新讀取 Sources 試試看。
安裝 Dropbear 我的 SSH 是使用 Dropbear，你可以透過 http://cydia.ichitaso.com 這個 Source 來安裝。
安裝 usbmuxd 我是使用 USB 的方式來連接手機裝置的，所以先在 macOS 上安裝 usbmuxd
brew install usbmuxd 並且透過指令將特定的 port 來代理原本用來連接 ssh 的 port 22。
iproxy 5678 22 接著我們就可以利用 port 5678 來連上裝置了。</description></item><item><title>Archie 的斜槓記錄 2019-12</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-12/</link><pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-12/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense AdSense 的部分，12 月的獲利是 106.05 元，加入了 阿芬的菜園 的廣告，所以突破 100 元！
Bitfinex 12 月份的走勢
月初的時候一波下探，但後來有拉起來，所以整月份的收入為 $35.08
台股就沒什麼獲利了，所以都要等明年了😂
總收入 AdSense $106.05 Bitfinex $1,054.15 這個月總收入為 $1,160.2</description></item><item><title>Active Compilation Conditions</title><link>https://www.archie.tw/p/active-compilation-conditions/</link><pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/active-compilation-conditions/</guid><description>在 Xcode 7 以前的版本，我們若需要設立一些環境變數，需要透過 Other Swift Flags 來處理； 像是 -DDEBUG -DRELEASE 等，且在使用的時候，並不會自動檢查出是否正確。
而在 Xcode 8 加入了一個 Active Compilation Conditions，現在我們可以在裡頭新增 DEBUG、RELEASE 即可達到原先的效果，並且會在寫程式的時候，自動補全了！
file
我竟然到 Xcode 11 出來後才發現這點，畢竟原本就都寫好了😂</description></item><item><title>Archie 的斜槓記錄 2019-11</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-11/</link><pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-11/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense AdSense 的部分，上個月的獲利是 US$2.33 元，沒特別多做任何事，所以沒有特別的成長。
Bitfinex 十一月份的每日獲利走勢
總獲利一共 US$36.23
台股獲利 0056 的股利在這個月發放，共計 $6,637
總收入 AdSense US$2.33 Bitfinex US$36.23 股利 $6,637 這個月總收入 $7,812.1</description></item><item><title>AWS Certificate Manager 申請流程</title><link>https://www.archie.tw/p/aws-certificate-manager-%E7%94%B3%E8%AB%8B%E6%B5%81%E7%A8%8B/</link><pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/aws-certificate-manager-%E7%94%B3%E8%AB%8B%E6%B5%81%E7%A8%8B/</guid><description>AWS Certificate Manager 申請流程 我的這個網站架設在 AWS 的 EC2 上，搭配 Route 53 和 Load Balancer 以及這篇的主角 AWS Certificate Manager，這邊要迅速的記錄操作流程！
環境架設的文章寫在這
流程 申請憑證
新增網域名稱
這邊要注意的是，像我之前是申請 *.Archie.tw，這會導致一個問題就是 https://Archie.tw 就不會符合申請的格式，而我一直到昨天才修正這件事⋯⋯ 這邊建議是填寫 www.Archie.tw 和 Archie.tw，這樣不管使用者有沒有補上 www 都可以取得信任的大鎖🔒。
選取驗證方式
如果你是和我一樣，使用 Route 53，就選擇 DNS 驗證
新增標籤
這邊看個人，算是一個 tag 提醒自己用而已，我是沒有填寫。
最後 AWS Certificate Manager 就會要求你
就直接按下去就好了👌
以上便是透過 AWS Certificate Manager 申請憑證的流程，搞清楚的話不用幾分鐘就可以處理好了👍</description></item><item><title>Disable dark mode on iOS 13 in your application</title><link>https://www.archie.tw/p/disable-dark-mode-on-ios-13-in-your-application/</link><pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/disable-dark-mode-on-ios-13-in-your-application/</guid><description>在使用 Xcode 11 以後的版本開發時，應用程式會自動在 iOS 13 以後的系統跑 Dark mode； 而在還沒有準備好支援 dark mode 的情況下，會直接是一個悲劇的 UI⋯⋯
這時候你可以選擇⋯⋯
調整大部分的 UI 來支援 Dark mode 在你的應用程式中設立成一般模式 在你有新功能要上線且還未準備的情況下，建議你選擇後者會比較符合效益👌
方法就是這篇文章的主軸
file 就是在 Info.plist 設立 UIUserInterfaceStyle 為 light 或是 dark
如果只有特定的 UIWindow、UIViewController、UIView等需要調整時，可以找到它們底下的這個參數 overrideUserInterfaceStyle 來去做調整即可👌</description></item><item><title>Archie 的斜槓記錄 2019-10</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-10/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-10/</guid><description>這個月 Archie 的斜槓記錄又來啦！
AdSense 少少的 US$1.41
Bitfinex 這個月的年利率大約都落在 7 - 10 % 之間，不過最近因為習近平的一句話，有幾天上漲到 15 % 左右，但沒過多久就回歸到 9 % 的位置
所以這個月每日的利息走勢圖如下，多半時間是低於一塊美金的：
而這個月的收益為
台股獲利 這個月買賣股票加上屁偉（我弟弟）抽中上海商銀直接賣掉的分紅，一共獲利 $10,760 元。
總收入 美金持續下滑到 30.54 左右，所以 Bitfinex 那邊依然是被匯差吃死死⋯⋯😭
AdSense US$1.41 -&amp;gt; $43 元 Bitfinex US$24.68 -&amp;gt; $754.47 元 台股獲利 $$10,759 元 這個月的斜槓收入為 $$11551.45 / 50,000 = 23.10%
[||||______ 23% __________]
目前看起來 AdSense 那一塊真的太少了😂需要好好思考一下怎麼增加那一部分的收益🤔️ 而 11 月還會領到元大高股息 0056 的現金股利，希望台股獲利可以穩定👌</description></item><item><title>Checklist template</title><link>https://www.archie.tw/p/checklist-template/</link><pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/checklist-template/</guid><description>這是一個新的分類，不侷限於 iOS 或是程式開發的層面，對於我而言是一個新的領域；這有點像是檢查清單、必做清單或是 SOP 等概念，簡單舉幾個例子
雙 NP 流程 確認原電信合約 和原電信商解約 攜碼至另一家電信的預付卡 至通訊行辦理攜碼方案 等預付卡開通，使用其卡片 等原電信商開通 Cocoapods binary 流程
gem install cocoapods-binary 在 Podfile 最上方加入 plugin 'cocoapods-binary' 和 all_binary! pod install 阿齊推薦的宜蘭十個小吃 阿德魯肉飯 ⋯⋯ 諸如此類的，這些流程它可以是一個個人的 SOP 或是有點像是小教學，而這當然只是一個我自己的範本，你可以刪刪減減成自己的版本👌
十月份先以這個分類為測試，若流量大一些的話，再擴大這個專案吧！</description></item><item><title>【Checklist】雙 NP 流程</title><link>https://www.archie.tw/p/checklist%E9%9B%99-np-%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 05 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/checklist%E9%9B%99-np-%E6%B5%81%E7%A8%8B/</guid><description>【Checklist】雙 NP 流程 確認原電信合約 和原電信商解約 攜碼至另一家電信的預付卡 至通訊行辦理攜碼方案 等預付卡開通，使用其卡片 等原電信商開通 2019 執行的心得文
2017 執行的心得文</description></item><item><title>Archie 的斜槓記錄 2019-09</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-09/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E8%A8%98%E9%8C%84-2019-09/</guid><description>這個月 Archie 的斜槓記錄又來啦！ AdSense 廣告部分，九月份上架了兩個 App； 一個是 iOS 13+ 的匯率計算機、一個是 Flip clock，而流量都還是十分低的狀態，不過金額比上個月多了 US$ 1.2，來到了 US$ 2.53 。
Bitfinex 而九月份的放貸收入為 US$ 30.33，受到了虛擬貨幣價格走低的影響，這部分是比上個月來得少的，少了 US$ 1.35。
台股獲利 這個月領了合作金庫的股利 4,653 元，以及買賣其他股票小賺了 985 元。
總收入 加上目前美金匯率也降到了 31，使得總獲利其實沒什麼成長。
AdSense US$ 2.53 ➡️ $78.43 Bitfinex US$ 30.33 ➡️ $940.23 台股獲利 $5,548 額外收入 $1,500 這個月斜槓收入為 $8,066.55
8,066.55 / 50,000 = 16.1331 %
[|||_______ 16% __________]
不過十月份印象中沒有股利可領，下一篇大概會少上許多吧😭</description></item><item><title>雙 NP：中華電信➡️台灣大哥大➡️中華電信 v2</title><link>https://www.archie.tw/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1-v2/</link><pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1-v2/</guid><description>繼上次雙 NP 之後，合約又來到了即將到期的時候，而今日因昨晚發燒請了病假，中午狀況好轉後便順道處理了合約的問題。
這次打算申辦的是
購機-699
每月費用大約如下 699 - 7,000 / 30 = 466 元
大地遊戲開始 2019-09-27 12:56 中華電信 由於我的合約到期日為 10/03，故要先到中華電信進行提前解約並繳納提前解約終端設備補貼款（我的部分是 106 元）
2019-09-27 13:01 台灣大哥大直營門市 告知從中華電信攜碼轉預付卡，而將於 2019/9/28 開通台灣大哥大門號（可以接電話、沒網路）
2019-09-27 13:10 地標網通 帶著前面的收據和申請書來申請，而中華電信的合約內容比較多，所以簽署了比較多份文件。 將於 2019/9/29 恢復成中華電信門號🎉
全部在羅東跑完大概半小時內可以處理完畢，再來就是等各家電信開通服務即可！
其他方案可以到地標網通查詢，或是其他通訊行做詢問。</description></item><item><title>如何更改模擬器上的狀態列</title><link>https://www.archie.tw/p/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%A8%A1%E6%93%AC%E5%99%A8%E4%B8%8A%E7%9A%84%E7%8B%80%E6%85%8B%E5%88%97/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%A8%A1%E6%93%AC%E5%99%A8%E4%B8%8A%E7%9A%84%E7%8B%80%E6%85%8B%E5%88%97/</guid><description>這篇就來談談我是如何更改模擬器上的狀態列🎤
在 Xcode 11 Beta 3 以前，我是使用 SimulatorStatusMagic 而今天要弄截圖的時候發現，原來在 Xcode 11 Beta 4 之後，有內建的使用方法！
我喜歡讓 App store previews 上的時間顯示我自己的生日🎂算是一個小巧思（但沒人想知道）
而現在可以透過內建的指令來完成這件事，其中你可以使用下列這些
xcrun simctl status_bar 指令
像是更改目前開著的模擬器時間：
xcrun simctl status_bar booted override --time &amp;quot;02:01&amp;quot; 成果圖
而若是你的 Xcode 版本是 6 - 10 的話，就繼續使用 SimulatorStatusMagic 吧👌</description></item><item><title>SwiftUI + Google AdMob</title><link>https://www.archie.tw/p/swiftui-google-admob/</link><pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/swiftui-google-admob/</guid><description>這篇是一個簡單介紹 UIViewControllerRepresentable 的範例， 由於 Google AdMob 的 GADBannerView 不像上次提及的 UITextField 一樣，可以直接使用 UIViewRepresentable 來包裝；原因是它必須設置一個 rootViewController，也就意味著我們需要使用 UIViewControllerRepresentable 才能完成它。
Interfacing with UIKit 透過這個 Apple 官方的教學當中，我們可以從 UIPageViewController 的範例來做發想，故我的實作方式會是這樣：
import GoogleMobileAds import SwiftUI import UIKit struct GADBannerViewController: UIViewControllerRepresentable { func makeUIViewController(context: Context) -&amp;gt; UIViewController { let view = GADBannerView(adSize: kGADAdSizeBanner) let viewController = UIViewController() view.adUnitID = &amp;#34;your ad unit id in there.&amp;#34; view.rootViewController = viewController viewController.view.addSubview(view) viewController.view.frame = CGRect(origin: .zero, size: kGADAdSizeBanner.size) view.load(GADRequest()) return viewController } func updateUIViewController(_ uiViewController: UIViewController, context: Context) {} } 如果需要處理 Delegate 的部分 你可以參閱上次 TextField 的處理方式，建構一個 Coordinator 來進行相關的作業👌</description></item><item><title>對於 SwiftUI onDisappear 的誤解？</title><link>https://www.archie.tw/p/%E5%B0%8D%E6%96%BC-swiftui-ondisappear-%E7%9A%84%E8%AA%A4%E8%A7%A3/</link><pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%B0%8D%E6%96%BC-swiftui-ondisappear-%E7%9A%84%E8%AA%A4%E8%A7%A3/</guid><description>在接觸 SwiftUI 的這段時間以來，我一直在試著釐清一件事情，那就是
onDisappear 到底是不是壞的！
這件事情很玄，畢竟網路上大部分的資訊都告訴我們 onAppear 類似於 viewDidAppear、onDisappear 類似於 ViewDidDisappear，然後再補上一句
Note: In the current SwiftUI beta onDisappear will never be called. by HackingWithSwift
或是你可以看到在 StackOverFlow 上大家是這麼討論的
討論串
接著，在這一路以來，你又曾經碰過真的是 Apple 的 bug，所以你就會很理所當然地認為⋯⋯
沒錯，onDisappear 就是壞的！
直到認真找找官方文件到底有沒有使用到 onDisappear 的範例，於是找到了這篇 並下載下來研究發現
onDisappear 是會動的⋯
這代表著一件事，就是其實是我誤解它的使用方式，而非它是壞的。 來看看官方的這個 View
struct ProfileHost: View { @Environment(\.editMode) var mode @State var profile = Profile.default @State var draftProfile = Profile.default var body: some View { VStack(alignment: .</description></item><item><title>📒 SwiftUI + CoreData 的實戰心得🔥</title><link>https://www.archie.tw/p/swiftui-coredata-%E7%9A%84%E5%AF%A6%E6%88%B0%E5%BF%83%E5%BE%97/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/swiftui-coredata-%E7%9A%84%E5%AF%A6%E6%88%B0%E5%BF%83%E5%BE%97/</guid><description>SwiftUI + CoreData
這篇文章會紀錄我在目前的 side project 上，如何在 SwiftUI 下導入 CoreData； 而如同 在 SwiftUI 處理中文輸入法所會遇上的問題 所提及的，SwiftUI 身為一個還在測試階段的 framework，我們必須將當下的開發環境紀錄下來，以避免造成日後官方修正所造成的誤解。
開發環境 Xcode 11 Beta 7（但顯示為 Beta 6 - 11M392r ） macOS Catalina - 19A546d iOS 13.1 Beta 使用情境 我要做一個貨幣的列表，並讓使用者可以對相對應的貨幣做隱藏與否，所以規格大概是需要一個 List，而 Row 裡頭呈現貨幣的名稱以及用 Toggle 來做控制隱藏的開關。
CoreData Model - Currency
Row 的部分 在 Xcode 11 Beta 5 之後， NSManagedObject 可以視為一個 @ObservedObject，所以我們可以不必再弄一個 ManageRowModel，而是直接使用 NSManagedObject 來連動。 這邊我需要以英文大寫來顯示貨幣名稱以及一個控制是否顯示在主畫面上的開關。
struct ManageRow: View { @ObservedObject var currency: Currency var body: some View { HStack { VStack { Text(currency.</description></item><item><title>SwiftUI 上的鍵盤處理方式</title><link>https://www.archie.tw/p/swiftui-%E4%B8%8A%E7%9A%84%E9%8D%B5%E7%9B%A4%E8%99%95%E7%90%86%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/swiftui-%E4%B8%8A%E7%9A%84%E9%8D%B5%E7%9B%A4%E8%99%95%E7%90%86%E6%96%B9%E5%BC%8F/</guid><description>在 iOS 的開發過程之中，難免會碰到一個狀況，那便是 UITextField/ UITextView 被鍵盤所遮住了⌨️ 在 UIKit 之下，多數人會使用套件來做全域的處理，如 IQKeyboardManager 就是一個十分經典的解決方案。
來說說 SwiftUI 上的鍵盤處理方式 在 SwiftUI 上，我們也可以很優雅地處理這一塊，如在 List 元件中，只需要分別監聽 UIWindow.keyboardWillShowNotification 和 UIWindow.keyboardWillHideNotification，以及加上個 .animation(.default) 來優化使用者體驗。
var body: some View { List(viewModel.rowModels, rowContent: DemoRow.init) .padding(EdgeInsets(top: 0, leading: 0, bottom: bottomPadding, trailing: 0)) .onReceive(NotificationCenter.default.publisher(for: UIWindow.keyboardWillShowNotification), perform: updateFrame) .onReceive(NotificationCenter.default.publisher(for: UIWindow.keyboardWillHideNotification), perform: updateFrame) .animation(.default) } 完整的 struct 可以在 GitHub 上查看👍
成果動畫
有任何問題歡迎在底下留言👏有寫法上的建議可以直接在 GitHub 上反應👍 有想看看一些廢話的話則是可以在 Twitter 直接找到我喔！😂</description></item><item><title>Archie 的斜槓紀錄 2019-08</title><link>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2019-08/</link><pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2019-08/</guid><description>這篇是什麼？ 這篇文章的內容並不會圍繞 iOS 或是 Swift 等，而是投資理財的部分，其中並不會有什麼教學或是分析，單純只是我這個月的損益總結而已。
2019 年 8 月份總結 Adsense 其實我一直沒有在看這方面的收入，不過看來要加把勁在廣告上才是💪 大多數都是從一、兩個我沒有在維護的 App 來的⋯⋯ 九月份會開始掛上網站的廣告和看能不能在 iOS 13 正式版上線的時候， 將一個由 SwiftUI + Combine 所編寫的 side project 弄上架💦
Bitfinex 我有在 Bitfinex 搭配 Coinlend 進行放貸，並在 8/9 加碼了 $ 50,000 元進去 八月份的報表大概如下 共獲利了 USD $ 31.68
台股股利 這個月領了三次股利，共計 $ 1,596 元
八月份總收入 Adsense USD $ 1.33 Bitfinex USD $ 31.68 台股股利 $ 1,596 元 共計 $ 2,629.87 元</description></item><item><title>在 SwiftUI 處理中文輸入法所會遇上的問題</title><link>https://www.archie.tw/p/%E5%9C%A8-swiftui-%E8%99%95%E7%90%86%E4%B8%AD%E6%96%87%E8%BC%B8%E5%85%A5%E6%B3%95%E6%89%80%E6%9C%83%E9%81%87%E4%B8%8A%E7%9A%84%E5%95%8F%E9%A1%8C/</link><pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%9C%A8-swiftui-%E8%99%95%E7%90%86%E4%B8%AD%E6%96%87%E8%BC%B8%E5%85%A5%E6%B3%95%E6%89%80%E6%9C%83%E9%81%87%E4%B8%8A%E7%9A%84%E5%95%8F%E9%A1%8C/</guid><description>最近開始在嘗試把玩 SwiftUI 並打算作為一個 side project 的主要 UI 編寫方式，這篇文章則是其中一個使用情境所遇上的困難處。
開發環境 Xcode 11 Beta 7（但顯示為 Beta 6 - 11M392r ） macOS Catalina - 19A546d iOS 13.1 Beta 記錄這點蠻重要的，因為可能過個幾版這篇文章就沒參考價值了😂 還沒有下載更新的朋友，可以快去更新一下！
使用情境 我要來做一個搜尋的功能，讓使用者可以輸入關鍵字，並自動搜尋完後將結果呈現在下方👏
於是我們可以用兩個 UI 元件來達成這件事
TextField List 並寫一個 @Binding var 或是 @ObservedObject var 來讓 TextField 的 text 有個 binding 的地方，當它的值有更新時，觸發搜尋的動作🚀 而搜尋完的結構再來更新畫面上的 List。 聽起來沒什麼毛病，對吧？
實際上你會遇上的問題⋯ 當你想和我一樣，用拼音的輸入方式時；不論是你拼音還是注音，當你按下第一個音時，便會跑一次上述的流程了⋯⋯ 而我們所期望的流程應該是使用者選完字後再進行搜尋，這點在目前的 TextField 是做不到的，因為它不會判別目前是否有還沒拼完音的狀況就發動了。
那該怎麼辦呢？ 喵神這麼說
你可以查看一下當時的相關推文
我的作法就是以 UIViewRepresentable 來包裝，詳細的程式碼可以到 GitHub 查看👍
成果 當輸入了 luo dong 但是還沒選字的話並不會有動作。</description></item><item><title>建立 Xcode 的檔案範本</title><link>https://www.archie.tw/p/%E5%BB%BA%E7%AB%8B-xcode-%E7%9A%84%E6%AA%94%E6%A1%88%E7%AF%84%E6%9C%AC/</link><pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%BB%BA%E7%AB%8B-xcode-%E7%9A%84%E6%AA%94%E6%A1%88%E7%AF%84%E6%9C%AC/</guid><description>什麼是範本？ 在新增檔案的時候，會有預設的這幾種類型可以選擇；而當我們有一些自己常用的架構，如 Coordinator、ViewModel 等，可以自建一個範本來使用。 下面舉例幾個預設的 Swift 檔案
Swift File 位置在 /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Swift File.xctemplate
//___FILEHEADER___ import Foundation SwiftUI View 位置在 /Applications/Xcode-beta.app/Contents/Developer/Library/Xcode/ExtraTemplates/File Templates/User Interface
//___FILEHEADER___ import SwiftUI struct ___FILEBASENAMEASIDENTIFIER___ : View { var body: some View { Text(/*@START_MENU_TOKEN@*/&amp;#34;Hello World!&amp;#34;/*@END_MENU_TOKEN@*/) } } #if DEBUG struct ___FILEBASENAMEASIDENTIFIER____Previews : PreviewProvider { static var previews: some View { ___FILEBASENAMEASIDENTIFIER___() } } #endif 這些是跟著 Xcode.app 走的，而若是我們使用者自定義要使用的，得放在 /Users/UserName/Library/Developer/Xcode/Templates 先建立一個資料夾，或是可以到上述的位置複製一份過來。 需要至少三個檔案
FILEBASENAME.swift TemplateIcon.png TemplateInfo.plist 我自己的使用方式是複製系統的 Swift file 來做修改 🔧 也比較好去熟悉可替換文字和 header 的使用方式 👍</description></item><item><title>Get ETH balance and tokens balance</title><link>https://www.archie.tw/p/get-eth-balance-and-tokens-balance/</link><pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/get-eth-balance-and-tokens-balance/</guid><description>前言 最近都在處理區塊鏈相關的問題，其中一個就是怎麼直接透過節點（****.infura.io）來取得 ETH 和其他 ERC-20 的地址餘額（balance）。
JSON RPC ETH 節點所使用的 request body 是依照 JSON RPC 的方式，也就是我們所使用的 request path 都是相同的，像是主要的 https://mainnet.infura.io ；不同的是，我們可以透過不同的 body 內容來區別不同的需求。
基本的 body 格式 { &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;method name&amp;#34;, &amp;#34;params&amp;#34;: [], &amp;#34;id&amp;#34;: 1 } 取得 ETH 餘額 取得 ETH 餘額的方式較為單純，節點有提供一個 method 是 eth_getBalance，使用起來如下
{ &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;eth_getBalance&amp;#34;, &amp;#34;params&amp;#34;: [&amp;#34;你的 ETH 地址&amp;#34;, &amp;#34;latest&amp;#34;], &amp;#34;id&amp;#34;: 1 } 其中這邊的 latest 意思是指向最新的那個區塊取資料的意思；
我們便可以得到 response：
{ &amp;#34;id&amp;#34;:1, &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;result&amp;#34;: &amp;#34;0x0234c8a3397aab58&amp;#34; // 158972490234375000 } 其中注意到一點是，result 所回應的是你這個地址有幾聰的 hex 字串，所以當我們取得的時候得注意一下。</description></item><item><title>BIP-39 Mnemonic validate</title><link>https://www.archie.tw/p/bip-39-mnemonic-validate/</link><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/bip-39-mnemonic-validate/</guid><description>前言 最近處理了一些加密貨幣的問題，其中一個是助記詞的驗證，這邊將會解釋助記詞的生成和驗證方式。
生成助記詞 首先我們這邊所介紹的是助記詞生成方式，先建立一個 128 bytes 的隨機序列，也就是隨機產生 16 個 UInt8 的序列；
主要有分成 128、160、192、224、256 bits（每 32 bits 做為一個區間），而下列會以 128 bits 作為流程解釋。
對隨機序列加密（SHA256） 我們對剛剛所產生的序列做 SHA256 加密，便會得到由 32 個 UInt8 所組成的 Array。
Checksum 用來驗證助記詞是否正確的方式是透過 Checksum 來辨別，而 Checksum 的 size 為序列的長度 / 區間，如我們這邊所提及的 128 / 32 = 4；
意思便是剛剛所加密完的序列，我們取前面 4 bytes 的數值當作 checksum。
產生助記詞 而剛剛的隨機序列（128 bits）加上 4 bits 的 checksum 組成 132 bits，接著我們每 11 bits 作為一個分隔，也就可以得到 132 / 11 = 12 個數字。
而每 11 bits 作為一個分隔的意思也意味著數字的區間落在 0 – 2047 之間，也就是為什麼 12 字的助記詞所支援的單字庫數量為 2048。</description></item><item><title>Change login shells without chsh</title><link>https://www.archie.tw/p/change-login-shells-without-chsh/</link><pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/change-login-shells-without-chsh/</guid><description>前言 最近心血來潮更新了 brew，其中我正在使用的 shells – zsh 也一併更新了，才發現當初在從 bash 轉到 zsh 的時候有指定到版號的部分⋯也就是長得像這樣
/usr/local/bin/zsh-5.6.1 而 zsh 一更新之後，我的 iterm2 便很合理地打不開，因為找不到 login 的 shells； 當初我是在 bash 裡頭使用 chsh 來變更
chsh -s $(which zsh) 如今打不開 iterm2 該如何更改呢？
使用者與群組 首先先到 使用者與群組
並先解鎖來得到更改的權限
就可以按住 control 並點擊使用者，就會出現 進階選項 可以選擇
最後就可以在 登入 shell 那欄更改即可！</description></item><item><title>Resign .ipa</title><link>https://www.archie.tw/p/resign-.ipa/</link><pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/resign-.ipa/</guid><description>前言 我們都知道 iOS 是使用 ipa 檔案來安裝 app，而該如何換掉 ipa 裡頭的憑證呢？
解壓縮 首先，我們先將 Application.ipa 解壓縮，可以得到一個 PayLoad 的資料夾，裡頭包含著一個應用程式 Application。
移除舊有的簽章 接著我們透過 terminal 來進行移除的動作
rm -rf PayLoad/Application/_CodeSignature 找出你打算簽章的 provisionprofile
你可以透過 Apple developer 的網頁直接下載，或是查看本機裡頭的檔案，路徑會是在： ~/資源庫/MobileDevice/Provisioning Profiles/ 用 Finder 到那路徑之後，可以使用空白鍵來進行預覽， 透過名稱以及 SHA-1 來辨別。
嵌入 mobileprovision 到 app 之中 接著就複製並改名字放入 app 中
cp yourProvisionProfile.mobileprovision Payload/Application.app/embedded.mobileprovision 來製作簽章所需要的 entitlements.plist 先將 .mobileprovision 輸入成 profile.plist
security cms -D -i yourProvisionProfile.mobileprovision &amp;gt; profile.plist 再來利用 profile.plist 輸出成 entitlements.plist
/usr/libexec/PlistBuddy -x -c 'Print :Entitlements' profile.</description></item><item><title>CoreData with background task</title><link>https://www.archie.tw/p/coredata-with-background-task/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/coredata-with-background-task/</guid><description>前言 雖然在 iOS 上開發了幾年的時間，但一直到最近才開始使用 CoreData；之前在第一份工作的專案之中是使用 FMDB 來處理資料存取，而後續則是用了 Realm。
選擇的原因分別是當時 FMDB 的速度較其餘兩者快速，而後來看上 Realm 的跨平台特色，不過近期開發的感想是能以原生為主的話，就儘量降低對於第三方套件的依賴性。
這篇文章會記錄些什麼 其實這篇文章並不會從頭到尾寫下教學，而把重點放在一些我踩到的雷上，像是⋯⋯
記得要附上 sqlite 的路徑 原先我的 persistentContainer 的產生方式如下
lazy var persistentContainer: NSPersistentContainer = { let container = NSPersistentContainer(name: &amp;#34;OfflineWallet&amp;#34;) let description = NSPersistentStoreDescription() description.shouldInferMappingModelAutomatically = true description.shouldMigrateStoreAutomatically = true container.persistentStoreDescriptions = [description] container.loadPersistentStores { _, error in if let error = error { fatalError(&amp;#34;Unresolved error \(error), \(String(describing: error._userInfo))&amp;#34;) } } return container }() 在模擬器上存取了幾次，每次都有 save 且第二次進入畫面的時候，都可以 fetch 得到資料，但是只要重開 App 就會從頭來過⋯⋯</description></item><item><title>SwiftLint</title><link>https://www.archie.tw/p/swiftlint/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/swiftlint/</guid><description>SwiftLint 去年（2018）年末的時候，在 Twitter 上看到一些朋友們在討論著 SwiftLint 的使用，於是便也嘗試在目前公司的專案中導入，來解決 Coding Style 的問題。
Coding Style 的問題 剛進入到這家公司時，最痛苦的事情莫過於毫無章法的 Coding Style，這部分就不一一細數了，詳情可以看前陣子我的 Twitter 動態。
專案裡頭每個人寫的格式不同，會造成其他人在閱讀專案時，大幅增加理解彼此想法的成本
簡單來說就是浪費一堆時間在猜你在寫什麼
為了讓專案裡頭的大家有差不多的 Coding Style，可以選擇使用 SwiftLint 來處理這個情況。
實際嘗試 首先先以 SwiftLint 的官方教學來安裝和建構環境，並利用 Ethan 的 SwiftLint rules 當作基底來調整，先以別人的規範來看看差異性。
一跑下去便是直接噴了 3000+ issues⋯⋯
可以透過 Rules.md 來逐條看看定義並透過 example 來看怎麼算是 Non Trggering 和 Triggering；再來一條一條調整改進。
一些心得 目前公司的專案從 3000+ ➡️ 17 warings，而這 17 條是我還沒 refactor 到的 features，所以就還沒那麼急著去調整。
private_outlet 和 private_action 而其中一條規則 private_outlet 給我的感觸挺深刻的，由於我大多數的工作經歷是獨立開發居多，而每個 IBOutlet 都必須為 private 是第一份工作時所踩到的坑；當時公司共有兩位 iOS 工程師，彼此皆為 Junior 的程度，故沒什麼規範和概念，於是便會出現一些神秘的情境⋯⋯</description></item><item><title>AWS EC2 with WordPress</title><link>https://www.archie.tw/p/aws-ec2-with-wordpress/</link><pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/aws-ec2-with-wordpress/</guid><description>前言 Vultr 這個網站原本是在 Vultr 上開一台機器，每個月大概的費用為 USD $6 – 7 元之間，並利用 Certbot 自動更新 SSL 憑證。但後來發現不太會維護那台機器，時常因為記憶體造成資料庫錯誤，每隔兩三天就得去手動重新啟動來解決問題，乾脆就搬家到 WordPress.com 的服務。
WordPress.com 而 WordPress.com 的好處就是全部幫你處理好好的，然後我使用的是個人版的方案；NT$ 130 / 月，便有提供轉址的功能和一年份免費的網域。不過由於我自己是向 PChome 買 Archie.tw，所以主要是為了轉過去而付費。
但使用服務和自己開一台機器的差異性就在於彈性，像是安裝外掛便被放在商務版的功能之中，而費用為 NT$ 799 / 月。
這樣一用也用了一段時間，直到近期註冊了 AWS 的服務，便決定搬移到 AWS 上。
AWS 在 AWS 上新註冊的用戶可以擁有一年的免費方案，而這個網站目前使用到幾個 AWS 服務分別為
EC2 Load Balancer Certificate Manager Route 53 這邊來介紹我的流程：
Key Pairs 首先我們先到 EC2 的頁面選擇 NETWORK &amp;amp; SECURITY ➡️ Key Pairs 來建立一組 Key pair，用於之後連接到 EC2 instance
EC2 透過 AWS Markeyplace 開一台新的 instance，使用 WordPress Certified by Bitnami 搭配 t2.</description></item><item><title>POSTMAN – Pre-request script</title><link>https://www.archie.tw/p/postman-pre-request-script/</link><pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/postman-pre-request-script/</guid><description>POSTMAN 除了可以發送 request 到 server 之外，也有提供 pre-request script 的功能，讓我們可以撰寫 script 來進行一連串的測試。 舉個例子，我們有三支 API，邏輯為 名稱（Request body）【Response body】：
登入（帳號、密碼）【Token】 取得使用者的消費紀錄列表（Token）【Array】 取得單筆消費紀錄（Receipt ID）【Receipt】 在沒有撰寫 pre-request 之前若要取得 Receipt 的話，我們得要先呼叫 登入，接著手動複製 Token 到 取得使用者的消費紀錄列表 的 request body 裡頭，然後再複製⋯⋯（你們應該懂） 這邊就來教教如何先寫好 script，之後只要按最後你想得到的那支 API 就行了！
let account = &amp;#39;account&amp;#39; let password = &amp;#39;password&amp;#39; let index = 0 pm.sendRequest({ url: &amp;#39;https://Archie.tw/login?account=&amp;#39; + account + &amp;#39;&amp;amp;password=&amp;#39; + password, method: &amp;#39;get&amp;#39; }, function(err, response) { let token = response.json().token; pm.</description></item><item><title>Info.plist localized</title><link>https://www.archie.tw/p/info.plist-localized/</link><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/info.plist-localized/</guid><description>一些需要權限的功能都會需要在 Info.plist 裡頭加上說明，而這個說明要實作多語系則是建立一個 InfoPlist.strings（沒錯，名字就是這樣） 然後對相對應得 Key 填寫翻譯，像是：
NSLocationWhenInUseUsageDescription = &amp;quot;說明填寫&amp;quot;; 就可以在要使用位置的說明處顯示多語系的結果了。
至於其他的 Key 可以從 CocoaKey 官方文件以及 CoreFundationKey 找找。</description></item><item><title>Git submodule</title><link>https://www.archie.tw/p/git-submodule/</link><pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/git-submodule/</guid><description>有些時候，我們會需要幾個檔案和其他專案共用，而 iOS 的專案可以採取 CocoaPods / Carthage，但如果是要和其他語言共用的話該怎麼辦呢？
舉個例子，Server 和 Client 之間傳遞 Status Code，像是 code: 20000、20001、20002 之類的，收到 code 後要再做後續動作。
不過一份 Code 的定義散落在多個平台 / 專案之中，難免會有人雷的時候；不論是 client 記錯或是 server 回錯，而若是有個地方可以共同維護的話，便可以減少這種失誤。
所以就把那些文件（e.g .json）放到 repository 上，然後在你的專案之中：
git submodule add YourDocumentRepository.git 就會在你的專案資料夾中看到 clone 下來的結果，接著再將檔案拖拉至專案之中即可使用。 若要更新 submodule，則下
git submodule update 或是到 clone 下來的資料夾
git pull 像是如果懶得在每一個檔案都 import PodName，就直接弄成 Submodule 的方式來處理也行！</description></item><item><title>Create CocoaPods by yourself</title><link>https://www.archie.tw/p/create-cocoapods-by-yourself/</link><pubDate>Sat, 15 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/create-cocoapods-by-yourself/</guid><description>這篇文章會介紹建立自己的 CocoaPods 流程，而我當初是看了 David 的教學文所跑的流程。
首先，先建立一個新的 Pod
pod lib create YourPodName 接著依照自己的 Pod 內容回答問題，便會生成一個新的專案出來。
再來將 Code.Swift 丟到 Pods/Development Pods/YourPodName，也就是它預設 ReplaceMe.Swift 的那個地方。
最後 README.md 和 YourPodName.podspec 寫一寫就完成了 Pod 的準備。
而預設的 REAMME.md 裡頭，有一個 CI Status，你可以移除或者到 Travis.CI 建構；
從 Travis.CI 那邊可以得知如何建構一個 .travis.yml。
都準備好之後，在 GitHub 上開一個 repository 來放置，記得要放上 tag 標記目前的版本。
pod spec lint YourPodName.podspec 最後就送出去就好了！
pod trunk push YourPodName.podspec 如果你沒有註冊過的話，得先註冊一下：
pod trunk register email@domain.com 'Your Name' 而如果你有在 .podspec 裡頭填寫你的 Twitter 的話，就會收到 CocoaPods 貼的文！
如果你搜尋不到你的 Pod 的話，可以清除目前的 cache 就可以順利找到了！</description></item><item><title>UUID with version 3, 5 and name spaces</title><link>https://www.archie.tw/p/uuid-with-version-3-5-and-name-spaces/</link><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/uuid-with-version-3-5-and-name-spaces/</guid><description>在 Swift 裏頭，預設的 UUID 只能從 UUID() 來產生，或者是從另一個 UUID 來產生， 這邊來記錄一下如何從 String 來產生 UUID。 首先，先在 Bridge-Header.h 裡頭加入
#import &amp;lt;CommonCrypto/CommonCrypto.h&amp;gt; 再來寫個 UUID 的 extension：
extension UUID { enum UUIDVersion: Int { case v3 = 3 case v5 = 5 } enum UUIDv5NameSpace: String { case dns = &amp;#34;6ba7b810-9dad-11d1-80b4-00c04fd430c8&amp;#34; case url = &amp;#34;6ba7b811-9dad-11d1-80b4-00c04fd430c8&amp;#34; case oid = &amp;#34;6ba7b812-9dad-11d1-80b4-00c04fd430c8&amp;#34; case x500 = &amp;#34;6ba7b814-9dad-11d1-80b4-00c04fd430c8&amp;#34; } init(version: UUIDVersion, name: String, nameSpace: UUIDv5NameSpace) { // Get UUID bytes from name space: let spaceUID = UUID(uuidString: nameSpace.</description></item><item><title>Socket.IO</title><link>https://www.archie.tw/p/socket.io/</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/socket.io/</guid><description>這篇文章會介紹有關於 Socket.IO 在 server 端以及 iOS 端的一些實作分享。
Server 首先我們可以先從 Socket.IO 的 Get started 開始，它是以 Node.JS 所編寫的，所以先在資料夾位置執行
npm init 邊可以取得基本的一些檔案和 package.json。 接著安裝 Socket.IO 所需要的 express
npm install --save express@4.15.2 然後新建一個 index.js 的檔案，貼上
var app = require(&amp;#39;express&amp;#39;)(); var http = require(&amp;#39;http&amp;#39;).Server(app); app.get(&amp;#39;/&amp;#39;, function(req, res){ res.send(&amp;#39;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#39;); }); http.listen(3000, function(){ console.log(&amp;#39;listening on *:3000&amp;#39;); }); 這樣待會執行 node index.js 的時候便可以從 http://localhost:3000 來連上這個 server。
確認 server 目前是可以連上後，便開始安裝 Socket.IO 到其中
npm install --save socket.io 並在 index.js 裏頭加上 Socket.</description></item><item><title>StatusBarStyle</title><link>https://www.archie.tw/p/statusbarstyle/</link><pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/statusbarstyle/</guid><description>最近改寫了 StatusBarStyle 的控制方式，從 iOS 9 之前是使用
UIApplication.shared.statusBarStyle = .default 並在 info.plist 的 View controller-based status bar appearance 欄位設為 NO。 而後來則改為覆寫 preferredStatusBarStyle 的方式，就不用在 viewWillAppear / viewWillDisappear 的時候手動控制 StatusBarStyle。 首先先確認 info.plist 之中 View controller-based status bar appearance 是為 YSE， 代表我們是透過 View controller-based 的方式來更改 status bar style。
override var preferredStatusBarStyle: UIStatusBarStyle { return .default } 而配合 UINavigationController 的使用，可以以 Subclass 或是 Extension 的方式來實作， 這就得看專案需求了。
Subclass 在 BaseNavigationController 裏頭，利用 childForStatusBarStyle 回傳要呼叫哪個 UIViewController 的 preferredStatusBarStyle
override var childForStatusBarStyle: UIViewController?</description></item><item><title>Xcode beta with CocoaPods</title><link>https://www.archie.tw/p/xcode-beta-with-cocoapods/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/xcode-beta-with-cocoapods/</guid><description>Xcode 10 beta 的 Swift 版本為 4.2，而若你目前所使用的 Pods 多數為 Swift 4 的話，該怎麼辦呢？
你可以在 Podfile 裏頭加上全域的參數來規範所有 Pods 的 Swift version：
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&amp;#39;SWIFT_VERSION&amp;#39;] = &amp;#39;4&amp;#39; end end end 如此一番便可以輕鬆地在 Pods 還沒全面支援 Swift 4.2 時就可以使用 Xcode 10 Beta 開發👏</description></item><item><title>CompactMap vs flatMap</title><link>https://www.archie.tw/p/compactmap-vs-flatmap/</link><pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/compactmap-vs-flatmap/</guid><description>直接從 code 來看兩者之間和 map 的差異
CompactMap let scores = [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;four&amp;#34;, &amp;#34;5&amp;#34;] let mapped: [Int?] = scores.map { str in Int(str) } // [1, 2, 3, nil, 5] let compactMapped: [Int] = scores.compactMap { str in Int(str) } // [1, 2, 3, 5] flatMap let users = [User(name: &amp;#34;Archie&amp;#34;, scores: [1, 2, 4]), User(name: &amp;#34;ArchieChang&amp;#34;, scores: [3,2,5])] let mapped = users.map { $0.scores } // [[1, 2, 4], [3, 2, 5]] let flatMapped = users.</description></item><item><title>UserDefaults with Structure</title><link>https://www.archie.tw/p/userdefaults-with-structure/</link><pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/userdefaults-with-structure/</guid><description>有時候我們會將一些用戶資訊存在 UserDefaults 裡頭，是個方便且直覺的存取方式。
而 UserDefaults 並非是所有型別都可以接受，如你自己建構的 struct 或 class，
就需要先轉成 Data 的格式來存取。
這邊就來介紹如何存取 User 這個 struct：
struct User { var ID: String var name: String var email: String? } 這是一個簡單的 User structure，若要轉成 Data 的話，得先將 User 宣告成 Codable，
這樣就可以透過 PropertyListEncoder 和 PropertyListDecoder 來處理 User 和 Data 之間的 encode decode。
而最近喜歡使用 extension 的方式來處理 UserDefaults：
extension UserDefaults { var user: User? { get { guard let data = data(forKey: #function) else { return nil } return try?</description></item><item><title>Git LFS ( Large File Storage )</title><link>https://www.archie.tw/p/git-lfs-large-file-storage/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/git-lfs-large-file-storage/</guid><description>今天在更新 Blay 的 Pods 時，發現 Realm 的某個檔案（60.04 MB）超出了 GitHub 的上限（50.00 MB），所以無法順利地將檔案推上去 GitHub，而 Git 也自行 untracked 那個檔案，所以在 git status 上便失去了蹤影。
至於為什麼會將 Pods 的檔案全推到 GitHub 上呢？
而在 git push 的時候，有顯示解決的方法，便是今天的主題：
Git LFS 首先我們透過 brew 來安裝 git lfs
brew install git-lfs 接著繼續在 git 裡頭安裝
git lfs install 再來我們就來定義哪些檔案需要被 lfs track，像我這邊是這樣：
git lfs track 'Pods/Realm/core/librealmcore-ios.a' 然後可以透過指令來確認是否有被加入到 track 的名單
git lfs track git status 現在就可以從 git status 之中再次看到剛剛沒推成功的檔案被 track 了！
git lfs track 的內容會被記錄到 .gitattributes 裡頭，所以也一併推上 GitHub 即可完成！ git push 這樣便可以在 GitHub 上處理單個檔案超過 50.</description></item><item><title>Fastlane pilot issue</title><link>https://www.archie.tw/p/fastlane-pilot-issue/</link><pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/fastlane-pilot-issue/</guid><description>這是和防火牆有關的 issue
在 fastlane pilot 的 docs 有註記 Firewall Issues
可以透過
ENV[&amp;quot;DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS&amp;quot;] = &amp;quot;-t DAV&amp;quot; 來避免上傳的問題！</description></item><item><title>DeviceSupport</title><link>https://www.archie.tw/p/devicesupport/</link><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/devicesupport/</guid><description>每當 iOS Beta 更新時，原先的 Xcode 便會無法支援，需要透過從 Xcode Beta 的 DeviceSupport 複製新的版本到正式版之中才能使用； 反正都會做這件事，不如就將 Xcode Beta 裡頭的 DeviceSupport 上傳到 GitHub 上提供給 iOS 有更新，但還沒下載新的 Xcode Beta 的人使用吧！ 傳送門點我</description></item><item><title>ignore Pods warning</title><link>https://www.archie.tw/p/ignore-pods-warning/</link><pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ignore-pods-warning/</guid><description>在使用 CocoaPods 的時候難免會碰上 warning，原因不外乎就是使用的套件本身在 build 的時候所產生的警告，但不建議直接 unlock Pods 去修改，請以那專案修改，並在處理完後發送 Pull Request 造福大眾。 不過現階段來說，我們可以做的事情是忽略 Pods 的 Warning， 只要在 Podfile 裡頭加上
inhibit_all_warnings! 即可在目前的專案中忽略 Pods 相關的 warning。</description></item><item><title>Pods 到底需不需要放在 .gitignore？</title><link>https://www.archie.tw/p/pods-%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%94%BE%E5%9C%A8-.gitignore/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/pods-%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%94%BE%E5%9C%A8-.gitignore/</guid><description>若有使用 GitHub 所預設的 Swift .gitignore，你會發現在 CocoaPods 的部分寫著
# CocoaPods # # We recommend against adding the Pods directory to your .gitignore. However # you should judge for yourself, the pros and cons are mentioned at: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control # # Pods/ 用意如同字面上的意思，GitHub 所提供的預設會建議你上傳 Pods 的內容到 git server 上，
而我個人也認同這種做法，目前所想的原因如下：
可以完整地打包套件當前狀態到 git 上，以避免套件有異動 若你們有直接修改 Pods 裡頭的 Source code 的話，更加得上傳（不過完全不建議這麼做） git clone 下來之後可以不用再 pod install 一次 不過也是有些壞處，如套件越多時，造成 git 上的專案肥大等。
但是像是 Carthage 的話，就會建議加入到 .</description></item><item><title>upgrade git</title><link>https://www.archie.tw/p/upgrade-git/</link><pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/upgrade-git/</guid><description>前言 git 最近被發現有重大的漏洞，以我們能做的事情就是更新自己的 git！
在 macOS 上更新 在 macOS 上，預設的 git 為 git version 2.15.1 (Apple Git-101)， 所以我們需要先透過 brew 來安裝 git。 首先，我們先來更新 brew，這點和 CocoaPods 類似，需要更新本機端的項目； 順道升級 brew 目前裡頭的項目。
brew update &amp;amp;&amp;amp; brew upgrade 接著就透過 brew 來安裝 git
brew install git 最後再將 Symbolic link 處理一下就好了！
brew link --force git 現在我們確認一下 git 是否已經為新版本（git version 2.17.1）！
git --version</description></item><item><title>HEROKU</title><link>https://www.archie.tw/p/heroku/</link><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/heroku/</guid><description>前言 這幾個月透過家裡頭的桌機來定時跑爬蟲以及更新 Firebase 資料庫，不過電費也是一筆固定支出，所以趁今天想到這件事，便來搬移到免費的 HEROKU 來做這些事。
HEROKU 是一個有提供免費伺服器方案的平台，支援的語言算多，而我的爬蟲是以 Python 3.6 作為開發語言的，故選擇它來玩玩。 在免費的方案之中有一些限制，如 24 小時內得休息 6 小時之類的； 不過在這邊，我需要的只是一個可以執行 Cron Job 的地方，所以不需要升級主機的部分。 目前我的 HEROKU 裡頭包含著三個動作：
每天台灣時間 00:00 時，到星座網爬蟲並記錄當日運勢到 Firebase 每天台灣時間 09:00 時，到 PTT CodeJob 以及 Soft_Job 版搜尋 iOS 相關的文章，並 mail 到我的信箱 每天台灣時間 12:00 時，爬 PTT 一些熱門看板的文章並發佈到機器人部落格以及機器人推特之中 我分成三個 .py 檔案，下方會說明我的作法。 簡單的建構步驟 首先，先到 HEROKU 的 dashboard 建立一個新的 App，接著照著它的敘述完成 Git 的建置。 我在資料夾當中，放入了下列的檔案：
PTT.py – 12:00 該做的事 iOS.py – 09:00 該做的事 Astro.py – 00:00 該做的事 requirements.</description></item><item><title>Commitizen</title><link>https://www.archie.tw/p/commitizen/</link><pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/commitizen/</guid><description>閒聊一下 最近處於求職的階段，評估一份職缺的觀點也和過往不同； 以這篇文章來說，Git Commit Style 便是其中一點，詢問對方是否有固定的 commit 格式， 就可以大致上瞭解團隊的風格是哪種。 若還沒有個規範，或是想要參考的，可以繼續閱讀下去。
Git Commit 是以 AngularJS 的格式，區分成
&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;body&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;footer&amp;gt; 其中 type、scope、subject、body、footer 等，有一定的規範， 詳細的內容可以在 angular.js/DEVELOPERS.md 看到。 這篇文章主要要介紹的是一個可以讓 commit 符合上述規範的工具 – Commitizen。
Commitizen Commitizen 是以 Node.js 所開發出的一套工具，使用者可以透過它來處理 commit 的風格一致性。
安裝 我們可以透過 npm 的方式來取得
npm install -g commitizen 並且安裝 cz-conventional-changelog
npm install -g cz-conventional-changelog 在電腦中安裝完上述兩者之後，先切換到你所開發的 iOS 專案資料夾底下， 由於 Commitizen 是以 Node.js 開發，你需要在 iOS 專案裡頭建構一些 npm 所需要的環境， 故記得補上 npm 初始化以及使用 convertional-changelog</description></item><item><title>iOS Taiwan jobs</title><link>https://www.archie.tw/p/ios-taiwan-jobs/</link><pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-taiwan-jobs/</guid><description>iOS Taiwan jobs 緣起 最近剛把手上的專案都告一個段落，便開始尋找工作上的合作機會。 恰巧看到 f2etw/jobs，透過 GitHub Issues 的方式提供工作資訊， 感覺挺好的，且是個大家都可以共同編輯的地方，於是便有了建立一個 iOS 版本的念頭。
和 f2etw/jobs 差異性 issue title iOSTaiwan/jobs 僅提供 iOS 的工作機會，且技術較為單純（Objective-C、Swift）， 所以便選擇在 issue title 上僅提供公司名稱而已； 職稱以及使用的語言則使用 label 來作為區分依據，如 Intern、Junior、Senior、Swift 等。
issue template 我先是參考了 f2etw/jobs 的範本，並加入部分 PTT Soft_Job 版上的徵才格式，如
員工是否需自備工具? (是/否) 公司地址(填寫詳細至號) 後記 並在 README 之中，附上一些求職的網站，如 Yourator、indeed 等； 裡頭也都先下好關鍵字，點擊連結可以直接看搜尋結果。 希望可以透過這個專案讓台灣的 iOS 工程師在求職路上有個幫助！
之後再陸續整合一些資源到 Archie.tw 以及 iOSTaiwan，仿效 f2etw 的模式， 有興趣的朋友歡迎多加利用👏</description></item><item><title>Word deletion shortcut in iTerm</title><link>https://www.archie.tw/p/word-deletion-shortcut-in-iterm/</link><pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/word-deletion-shortcut-in-iterm/</guid><description>在使用 iTerm 的時候，想要一次刪除一個字的話， 可以在 Preferences ➡️ Keys 新增一組 Keyboard Shortcut， Action 選擇 Send Hex Code，並填上 0x17 即可！
iTerm2</description></item><item><title>ProvisionedDevices</title><link>https://www.archie.tw/p/provisioneddevices/</link><pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/provisioneddevices/</guid><description>前言 這篇文章的內容會是記錄如何確認目前的 Provisioning Profile 擁有哪些測試裝置， 以便在使用 adhoc 打包時，確保裝置可以執行。
Provisioning Profile Path ~/Library/MobileDevice/Provisioning Profiles/ 在 terminal 下執行
security cms -D -I /path/to/MyProfile.mobileprovision 便可以看到相關的資訊，如下圖： ProvisionedDevices</description></item><item><title>Python – SMTP</title><link>https://www.archie.tw/p/python-smtp/</link><pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/python-smtp/</guid><description>前情提要 痞客邦最近「新增文章」API，不斷地出現未知的伺服器錯誤，而且從回應的時間來猜測的話， 感覺像是他們自己本身內部的錯誤導致 Time out 之類的。 礙於目前還無法在短時間內處理好一台伺服器建構多個 WordPress， 所以只好先將內容發佈到 Blogger 來解決當前的問題。 而我們只需要使用到發文的功能，所以就可以簡單利用電子郵件來發文；
Blogger 設定的「以電子郵件傳送」 使用電子郵件張貼填入電子信箱，並開啟「立即發佈電子郵件」 儲存設定 這樣只要寄信給設定的地址的話，Blogger 便會自動發文。
SMTP 首先在 Python 當中，我們可以使用 smtplib 來發送信件， 下列使用 gmail 為例：
import smtplib smtpserver = smtplib.SMTP_SSL(&amp;quot;smtp.gmail.com&amp;quot;,465) smtpserver.ehlo() smtpserver.login(username, password) 若你直接執行的話，可能會收到登入失敗的訊息； 由於 Google 在安全性設定上，會阻擋安全性較低的應用程式， 所以若要使用的話，則需要開啟相關設定： 登入與安全性 啟用 這樣的話，就可以順利地登入 gmail。 再來準備信件的內容並寄出：
from email.mime.text import MIMEText from email.header import Header from_address = &amp;#39;Archie.Chang.iOS@gmail.com&amp;#39; to_address = [&amp;#39;Archie.Chang.iOS@gmail.com&amp;#39;] message = MIMEText(html_body, &amp;#39;html&amp;#39;, &amp;#39;utf-8&amp;#39;) message[&amp;#39;From&amp;#39;] = from_address message[&amp;#39;To&amp;#39;] = to_address[0] message[&amp;#39;Subject&amp;#39;] = subject smtpserver.</description></item><item><title>Firebase Cloud Functions with Database and Messaging</title><link>https://www.archie.tw/p/firebase-cloud-functions-with-database-and-messaging/</link><pubDate>Thu, 18 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/firebase-cloud-functions-with-database-and-messaging/</guid><description>Cloud Functions Firebase 一直以來便是以 serverless 為主要的方向， 而 Functions 則是一個十分有趣的功能； 它可以自動地隨著事件的回應，如資料庫的異動或是收到 HTTP 的 requests 時，執行程式碼。 其中一個重點是，我們也不需要去管理或是 scale 伺服器。
Triggers Cloud Firestore Triggers Realtime Database Triggers Firebase Authentication Triggers Google Analytics for Firebase Triggers Crashlytics Triggers Cloud Storage Triggers Cloud Pub/Sub Triggers HTTP Triggers 範例 需求 Realtime Database 底下的資料有異動的話，進行推播
直接上 Code const functions = require(&amp;#39;firebase-functions&amp;#39;); const admin = require(&amp;#39;firebase-admin&amp;#39;); admin.initializeApp(functions.config().firebase); exports.updateTodayNews = functions.database.ref(&amp;#39;/today/{newsCategory}/updatedTime&amp;#39;).onWrite(event =&amp;gt; { const newsCategory = event.params.newsCategory; return admin.</description></item><item><title>Selenium</title><link>https://www.archie.tw/p/selenium/</link><pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/selenium/</guid><description>Selenium 需要在 Python 上操作瀏覽器的話，我會選擇使用 Selenium； 以爬蟲來說，和 requests 不同的地方在於， 像是在讀取網頁時，使用 Selenium 開啟瀏覽器的話可以幫我們處理掉渲染的問題。 這篇主要會以 Selenium 的方式來取得痞客邦的 Access Token。
先搞懂痞客邦的流程 首先，我們先到痞客邦的開發者網頁 PIXNET 或是可以直接到 API Explorer 的畫面 API Explorer 接下來會需要進行登入的動作 Login 登入成功後，便是授權給 API Explorer 權限來取得 Access token Granted 最後可以在 API Explorer 的畫面上看到 Access Token。 AccessToken
程式方面 我們會使用到 Selenium 的這些元件
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import Select from selenium.common.exceptions import NoSuchElementException from selenium.</description></item><item><title>Twitter Follow all users script</title><link>https://www.archie.tw/p/twitter-follow-all-users-script/</link><pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/twitter-follow-all-users-script/</guid><description>追隨所有 Twitter 用戶 之前在弄一個自動發文的機器人，便想要在 Twitter 上同步發送； 而苦無沒有人追隨的情況下，決定先來追隨別人， 看看對方是否會反追隨回來（？ 以結果來看，有一些些功用，互相追隨的機率大概 5 % 左右。 PTT 爆報機器人 儘管多數可能也是機器人加機器人好友，不過至少稍稍提升了痞客邦的流量。
Javascript var FOLLOW_PAUSE = 1250; var FOLLOW_RAND = 250; var PAGE_WAIT = 2000; __cnt__ = 0; var f; f = function() { var eles; var __lcnt__ = 0; eles = jQuery(&amp;#39;.Grid-cell .not-following .follow-text&amp;#39;).each(function(i, ele) { ele = jQuery(ele); if (ele.css(&amp;#39;display&amp;#39;) != &amp;#39;block&amp;#39;) { console.trace(&amp;#39;Already following: &amp;#39; + i); return; } setTimeout(function() { console.trace(&amp;#34;Following &amp;#34; + i + &amp;#34; of &amp;#34; + eles.</description></item><item><title>Crontab</title><link>https://www.archie.tw/p/crontab/</link><pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/crontab/</guid><description>Crontab Crontab 在 Ubuntu 裏頭是預載的，其功能是可以根據時間參數來執行工作排程； 它的格式如下：
* * * * * command to be executed 依序分別是 分鐘[0-59]、小時[0-23]、日期[1-31]、月份[1-12]、星期[0-6]、command 其中 星期 0 = 天的意思。
符號 「*」：不設限 「,」：分隔時段。例如：30 10,20 * * * command，代表早上十點半和下午八點半執行。 「-」：一段時間範圍。例如：15 9-12 * * * command，代表從九點到十二點的每個 15 分都執行一次。 「/n」：表示每個 n 單位間隔。例如：*/5 * * * * command，代表每隔 5 分鐘執行一次。 * * * * *：每隔一分鐘執行一次。 你也可以使用 @ 來取代五個參數：
@reboot：僅在開機的時候執行一次。 @yearly：一年執行一次，和0 0 1 1 * command效果一樣。 @annually：（和@yearly一樣） @monthly：一個月執行一次，和0 0 1 * * command效果一樣。 @weekly：一個星期執行一次，和0 0 * * 0 command效果一樣。 @daily：每天執行，和0 0 * * * command效果一樣。 @midnight：（和@daily一樣） @hourly ：每小時執行，和0 * * * * command效果一樣。 輸出 另外，需要設立 command 輸出的地點或方式； 如使用 Postfix 或是直接在 command 後方加上 &amp;raquo; /file_path，</description></item><item><title>Facebook 隱私權條款問題</title><link>https://www.archie.tw/p/facebook-%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE%E5%95%8F%E9%A1%8C/</link><pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/facebook-%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE%E5%95%8F%E9%A1%8C/</guid><description>由於之前上架的 App 有使用到 Facebook 的登入功能， 於是這幾天一直收到這類的信件： Demo 但是由於本身對這方面可以說是完全沒有涉略， 所以便找找有沒有什麼辦法解決。
Free Privacy Policy
於是找到了這個，回答五種題型便可以得到它們產生的條款， 再找個地方貼上補連結到 Facebook 即可！</description></item><item><title>CocoaPods</title><link>https://www.archie.tw/p/cocoapods/</link><pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/cocoapods/</guid><description>上一篇介紹 Carthage，這篇寫一下 CocoaPods。 其實我個人是先使用 CocoaPods，後來才部分改用 Carthage 作為主要的管理方式； 而 CocoaPods 的安裝方式也很簡單，可以透過 gem 來安裝：
安裝 sudo gem install cocoapods 不同於 Carthage 的 Cartfile，CocoaPods 的是使用 Podfile， 格式有些不同，不過都可以在資料夾下使用 Terminal 輸入初始化的指令：
pod init 系統就會自行建立一個 Podfile，並用 pod search 的指令來找找你要什麼東西。 弄完 Podfile 之後，就可以執行安裝進專案：
pod install 並打開它幫你建立的 .xcworkspace 就好了。
一些分享 可安裝的版本和 GitHub 上寫的不同？ CocoaPods 會建立一個 local 的所有 repo 資訊，若找不到的時候，可以先試著更新它： pod repo update Carthage 和 CocoaPods 是可以混用的</description></item><item><title>Carthage</title><link>https://www.archie.tw/p/carthage/</link><pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/carthage/</guid><description>Carthage 是一個套件管理的開源軟體，可以使用 Homebrew 安裝：
brew install carthage 和 CocoaPods 的差異在於它並不會將第三方的 Framework 直接加入專案， 而是獨立在外，並在 build 的時候直接將 framework 複製進去到 App 內； CocoaPods 的話則會在每次 build 的時候同時 build 你所匯入的 framework， 而隨著專案使用到的套件內容越多，則會花越多時間。
去中心化 這個詞最近隨著區塊鏈的爆紅，也常常可以看見。 不過在這邊的情境是，CocoaPods 是由它那邊搜集很多個 repo，提供給我們來安裝； 所以若 CocoaPods 的 repo 資料沒更新，或是作者只放在 GitHub 上，沒有提交到 CocoaPods 的話， 則無法使用。 而 Carthage 則沒有這方面的問題，可以自行將 GitHub 上的專案加入到 Cartfile
github &amp;quot;ReactiveX/RxSwift&amp;quot; 不過這也是比較麻煩的地方，我們就沒有辦法像 CocoaPods 一樣直接在 Terminal 下 pods search RxSwift 來取得資訊。
個人的使用方式 由於我自行在開發，同時會有很多個專案用到相同的 framework（e.g RxSwift、Siren）， 原本若是使用 CocoaPods 的話，則會在很多資料夾內都有一樣的東西； 而 Carthage 的話，則是將 FRAMEWORK_SEARCH_PATHS 都指定到同一個資料夾即可， 並在 Build phase 加上 Carthage 的 Run script。 而我大多數只會開發 iOS 的 App，Carthage update 的時候則可以只更新 iOS 的部分：</description></item><item><title>FireabseDatabase - Read</title><link>https://www.archie.tw/p/fireabsedatabase-read/</link><pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/fireabsedatabase-read/</guid><description>之前有寫過 FirebaseDatabase REST API的文章， 而這篇則會是在 iOS 上的使用。
安裝套件 由於 Google 認為 Carthage 的方式不符合他們的使用模式， 畢竟 Firebase 的 framework 並非是開源的， 所以只有提供 CocoaPods 的安裝方式或是直接下載檔案； 而我這邊就以 CocoaPods 來安裝 Firebase 相關的套件，其他則用 Carthage 來管理。
設定 我們在 Firebase console 那先建立好專案並匯入 GoogleService-Info.plist， 如果你有多個 Target 要使用的話，建議放在不同的資料夾，並且設定好 Target Membership。 並且要注意 Firebase console 內的 Database rules， 若沒有做 auth 相關內容的話，記得要調整； 如我開放給 App 讀取但不可寫入的話：
{ &amp;quot;rules&amp;quot;: { &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;, &amp;quot;.read&amp;quot;: true } } 接著在 AppDelegate.swift 中加入
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?</description></item><item><title>MKGeodesicPolyline</title><link>https://www.archie.tw/p/mkgeodesicpolyline/</link><pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/mkgeodesicpolyline/</guid><description>先來看看 MKGeodesicPolyline 在 Apple Developer Documentation 上的介紹： A line-based shape that follows the contours of the Earth to create the shortest path between the specified points.
繪製 Polyline 首先我們在建置 MKGeodesicPolyline 的時候， 給予它一個 [CLLocationCoordinate2D]，並宣告要繪製幾個點； 接著讓 MKMapView 新增進去。
let geodesicPolyline = MKGeodesicPolyline.init(coordinates: [start, end], count: 2) mapView.add(geodesicPolyline) 再來我們需要透過 MKMapViewDelegate 的 function 來定義 MKGeodesicPolyline 的 UI：
func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&amp;gt; MKOverlayRenderer { guard let polyline = overlay as? MKPolyline else { return MKOverlayRenderer(overlay: overlay) } let renderer = MKPolylineRenderer.</description></item><item><title>Siren – 通知使用者更新</title><link>https://www.archie.tw/p/siren-%E9%80%9A%E7%9F%A5%E4%BD%BF%E7%94%A8%E8%80%85%E6%9B%B4%E6%96%B0/</link><pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/siren-%E9%80%9A%E7%9F%A5%E4%BD%BF%E7%94%A8%E8%80%85%E6%9B%B4%E6%96%B0/</guid><description>我們時常可以在 App 之中看到，「目前有新版本可以提供下載」等相關的訊息； 而實作通知使用者更新的方法很多，這篇則是介紹一個開源的 Framework：
Siren Siren 的運作邏輯是，你可以透過版號來決定跳出什麼通知來提醒使用者， 並且提供多語系的訊息內容。 它會透過 Bundle Identifier 去 App Store 上尋找資訊， 再來比對版號執行後續動作。
版號的定義 1.0.123.5678 1：major 0：minor 123：patch 5678：revision 一般我個人的習慣是： major 會是在商業模式改變或是重大功能發布時，才會動到的； 而 minor 則是有必要的更新，像是嚴重的 bug 或是無法向下相容的異動。 patch 是更新一些 issue 或是修正 bug； revision 則讓它跟著 commit 的數量。
Siren 的設定 舉個例子，在 major、minor 有提升時； 像是從 1.0.0 -&amp;gt; 2.0.0 或是 1.0.0 -&amp;gt; 1.1.0， 我會希望舊的使用者一定要更新 App 才能使用， 則會設為強制更新（.force）。 而 patch 則讓使用則決定要不要更新，或是可以跳過此次更新。
Siren.shared.majorUpdateAlertType = .force Siren.shared.minorUpdateAlertType = .force Siren.shared.patchUpdateAlertType = .</description></item><item><title>UIActivityViewController</title><link>https://www.archie.tw/p/uiactivityviewcontroller/</link><pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/uiactivityviewcontroller/</guid><description>這些話寫在前面⋯⋯ 最近在開發的產品需要加入「分享」的功能， 希望將一些資訊及圖片分享到其他 App 或平台上； 這篇文章會先點出需求，再逐一闡述開發的過程。
需求 Facebook 分享 hash tag 及圖片 其餘分享文字及圖片和網址 實作 我們利用 UIActivityViewController 來呈現分享的選單，並將分享的內容塞入 activityItems: [Any] 之中； 而 applicationActivities 則設為 nil，並沒有要客製 activity。 若沒有需要依照不同類別做出不同的判斷，我們可以將內容放置進去； 像是 URL、String、UIImage等等。 而幾個特點要注意一下：
Facebook： String 只支援一個 hash tag（像是：“#Archie”），若超過或其他一般文字則不會顯示 有網址的話，就會顯示連結；意思是圖片和連結無法同時出現，會優先顯示連結 iMessage 若 String 裡頭的時間格式為 dd/MM/yyyy HH:mm 則可以點擊，並加入行事曆 圖片會以另一則訊息傳送 網址會以縮圖顯示（就如一般訊息收到的邏輯）
依照類別提供不同內容 首先，我們可以先看 UIActivityType：
extension UIActivityType { @available(iOS 6.0, *) public static let postToFacebook: UIActivityType @available(iOS 6.0, *) public static let postToTwitter: UIActivityType @available(iOS 6.</description></item><item><title>3D Touch</title><link>https://www.archie.tw/p/3d-touch/</link><pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/3d-touch/</guid><description>這些寫在前面⋯⋯ 最近剛從 iPhone 6 Plus 晉升到 iPhone X，其中一項硬體差異便是「3D Touch」； 而這也讓我花了一些時間，來加入 3D Touch 的相關功能開發。 這篇文章前半部會寫 3D Touch 在主畫面上的一些差異， 後半部才會補上 Swift 的相關寫法。
iOS 版本：11.1.1（15B150） 首先，先將 App 分成有 Today extension 以及沒有 Today extension 的這兩種：
郵件 – 有 Today extension
鬧鐘 – 沒有 Today extension
從這兩張圖的比較下，我們可以得知在 iOS 11.1.1 之中， 若有 Today extension 的 App，在 3D Touch 的快捷鍵之中， 會顯示 Today extension，而反之則僅會露出原本的 App icon。 另一點是，快捷鍵的順序是依 index 越小則越靠近 App icon； 所以使用者將 App 放置在畫面上半部或下半部會影響由上到下的順序。
鬧鐘 – 放置畫面下半部
所以便不必太在意快捷鍵的排序問題，包含 Today extension 順序也是。</description></item><item><title>失業給付 + 提早就業獎金</title><link>https://www.archie.tw/p/%E5%A4%B1%E6%A5%AD%E7%B5%A6%E4%BB%98-%E6%8F%90%E6%97%A9%E5%B0%B1%E6%A5%AD%E7%8D%8E%E9%87%91/</link><pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%A4%B1%E6%A5%AD%E7%B5%A6%E4%BB%98-%E6%8F%90%E6%97%A9%E5%B0%B1%E6%A5%AD%E7%8D%8E%E9%87%91/</guid><description>這些話寫在前面⋯⋯ 由於和上一間公司的工作方式處不來，而對方決定以資遣的方式來處理， 故便在六月中解鎖了「領取資遣證明」的成就。
知道對方要資遣你時，先確認幾件事 近三年內勞保是否有投保滿一年 對方是否通報勞保局 對方是否會開立資遣證明 至於對方是用什麼條款開立，個人是認為沒什麼差異。
若上述的答案皆為「是」的話，你可以⋯⋯ 申請「失業給付」，而這篇文章會以我申請的流程為主，並以流水帳的方式呈現。
2017/06/14（三） 對方中午開立資遣證明，並在上方註明最後工作日為 2017/06/16（五）， 也就是會支薪到週五的意思； 而上方會寫上這個月將依比例給付多少薪資以及資遣費計算結果。
當天，便電話聯繫板橋就業服務站，詢問相關資訊和預約失業給付申請； 而對方有提供給我幾項重點：
失業給付申請得在最後工作日的隔一天後，以我的案例是 2017/06/17（六）以後申請 可以透過電話進行預約申請，並建議於預約時間前十分鐘先去填寫書面資料 記得帶預計讓失業給付入帳的銀行簿子影本，或帶正本去影印 攜帶證件及資遣證明正本 新北市的就業服務站失業認定無需當日現場報到，而台北市則需要 2017/06/19（一） 上午便到板橋就業服務站填寫書面資料，並和服務人員進行後續動作； 期間對方和我閒聊一些工作上的事，以及職業選擇之類的， 並提供一些就業的資訊和講座。 流程上會需要在 14 天內，進行兩次以上的「找工作」； 對方會要求要上「台灣就業通」（或是其他政府機關提供的找工作平台）， 去申請面試，並於兩週後和服務人員回報狀況。 回報的內容是一張表，需要填寫完之後送回就業服務站，也就是「第一次失業認定」； 板橋就業服務站可以透過郵寄的方式，將表格回寄，並打電話給當時接洽的人員即可， 而台北市則需要再跑一趟親送。
2017/07/03（一） 打電話向服務人員確認狀況，並告知 14 天內沒有工作（以勞保投保記錄為主）， 請對方將第一次認定的申請書送到勞保局，而後續他們會繼續處理。
2017/07/04（二） 持讀卡機到勞保局網頁，以自然人憑證查詢相關進度和資訊； 這邊建議下載「勞保局行動服務」，並進行「個人查詢」的裝置認證， 認證完後，之後都可以透過此 App 查詢，無需再用讀卡機進行登入。
2017/07/12（三） 核付通過，並會在 3 至 5 個工作天匯款至當初提供的銀行戶頭之內。
2017/07/17（一） 收到第一個月的失業給付，而若還未找到工作，則每個月需要再進行認定； 不過我已經有在工作，故沒有進行後續的失業給付申請認定。
找到工作後，接下來呢⋯⋯ 當時在申請失業給付時，服務人員會告知「提早就業獎金」的申請規則和獎金計算方式： 為尚未領取失業給付金額（以我來說，便是 5 個月的失業給付金額） x 50% 一次性發放。
2017/10/05（四） 使用讀卡機到勞保局網頁線上申請「提早就業獎金」，兩分鐘內點選完後送出。
2017/11/01（三） 核付通過，並會在 3 至 5 個工作天匯款至「提早就業獎金」所申請的銀行戶頭之內。</description></item><item><title>重灌 macOS 的工程（下）- Terminal 篇</title><link>https://www.archie.tw/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8B-terminal-%E7%AF%87/</link><pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8B-terminal-%E7%AF%87/</guid><description>前情提要 重灌 macOS 的工程（上）
開始進入本篇 iTerm2 首先要先處理的，是 Terminal 的部分； 除了 macOS 所內建的 Terminal 之外，我目前嘗試使用 iTerm2， 主要是看上有較多個人化設定的部分。 而我所使用的主題風格是 Dracula，相關的安裝方式裡頭有蠻清楚的介紹。
Homebrew 這套相信大家都不會太陌生，而不清楚的人就在這邊簡單解釋一下， Homebrew 主要是負責 Mac 上的一些套件管理； 就有點像是 Swift package manager、CocoaPods 或是 Carthage。
zsh 在 iterm2 之中安裝完 homebrew 之後， 接著就繼續來安裝 zsh，其主要是用來取代原先內建的 bash， 也是這次重灌後開始嘗試使用的新玩意之一。 而在下載安裝完 zsh 後，會被默認安裝在 /usr/local/bin/zsh（或者出現 /usr/local/bin/zsh-5.4.2）， 我們要將 zsh 替換掉 bash，需要下一行指令 chsh -s /usr/local/bin/zsh-5.4.2 chsh 的意思便是 change shell，也就是將原本使用的 shell 換成指定路徑。 不過由於 macOS 對於 shell 有防範，所以你可能會得到這種錯誤訊息： non-standard shell 遇上這個時，我們就得編輯 /etc/shells，將我們剛剛所安裝的路徑放進， 讓系統明白這是一個可以拿來使用的 shell 路徑。</description></item><item><title>UIImage memory issue</title><link>https://www.archie.tw/p/uiimage-memory-issue/</link><pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/uiimage-memory-issue/</guid><description>今天要來分享的內容，是有關於 UIImage 的一個記憶體爆炸情況， 而我先闡述一下發現這問題的情境： 專案內有個功能會需要匯入大型圖片做縮放以及拖拉功能， 使用者可以切換大型圖片，而在點擊過多的圖片時，便會造成記憶體爆炸。
原先的做法 在使用者點擊叫出某張圖時，會使用 UIImage(name: ImageName) 來產生 UIImage 物件，並將畫面上的 UIImageView.image 設為它。 看起來蠻合理的，當使用者切換後，我會再生成一個新的 UIImage 物件，並取代前者； 這樣前者就應該會釋放掉記憶體空間了！
但⋯⋯事情並不是這樣發展 在使用者切換幾次後，發現記憶體只有一直往上增長，而未釋放掉； 意思是指雖然我將畫面上的 UIImageView.image 取代掉了， 不過實際上仍然佔據著記憶體空間⋯⋯
為什麼？ 上網查了一下後，發現 UIImage(named: ImageName) 這種生成方式， 會自行將取出來的圖片放置到 cache； 而上述的使用情況就會變成當使用者一切換，便會將另一張大型圖片放置到 cache 而未釋放掉前一張。
改良的做法 Data 在建構的時候，有一種選項是 .uncached， 也就是說，我們可以先將圖片以 Data 的方式打開，再轉回 UIImage， 則就可以避免掉它自動放置到 cache 而記憶體爆掉的情況。
if let url = Bundle.main.url(forResource: ImageName, withExtension: &amp;#34;.png&amp;#34;), let data = try? Data(contentsOf: url, options: Data.ReadingOptions.uncached) { let image = UIImage(data: data) imageView.image = image } 這樣就可以解決 UIImage 的 cache 導致記憶體爆炸的情況。</description></item><item><title>雙 NP：中華電信➡️台灣大哥大➡️中華電信</title><link>https://www.archie.tw/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1/</link><pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1/</guid><description>首先，先附上地標網通的價目表， 我所要選擇的方案是雙 NP 回中華電信的智慧大玩家 999 方案， 而方案內容是 24 個月，每月月租 999 元，4G 吃到飽，網內60分/網外50分/市話20分。 透過雙 NP 的流程，我可以拿到 11,000 元的攜碼折扣，而算一下每月月租費約為 (999 x 24 – 11,000) / 24 = 540.66667 元
闖關流程 第一步，先確認一下自己的合約狀況： 以我的例子來說， 合約原本內容：
我們可以看到，大多數的合約到期日為 10-03， 但由於第一項合約，其正是去年申請的老客戶優惠方案； 而它的到期日是在 12-23，所以我還是得到中華電話一趟來申請攜出。 於是我便在 10-03 當天的 17：30 左右， 到中華電信的長春服務中心辦理攜出業務。
從中華電信攜出 和櫃檯人員說明我要攜出門號，而她也沒有多問些什麼， 便請我提供資料以及詢問門號轉出費用 240 元， 是要選擇跟著當期帳單還是直接繳清。 選擇直接繳清後，並簽個名，就順利拿到收據離開了； 前後加上等候叫號的時間，約莫十分鐘。
還沒離開中華電信，便收到了相關通知簡訊。
到台灣大哥大辦理門號攜入 接著到附近的台灣大哥大林森北二直營服務中心， 一進去後副店長便詢問我門號，而當我表示要轉入 4 G 1.8 的方案時， 他便直接問我是否要雙 NP，以及原電信是否為中華電信！ 我點了點頭示意，便交出了雙證件和簽了兩處名字， 他告知我通常隔天就可以再到台灣大哥大辦理攜出， 一樣繳納 240 轉出費後便可以去走接下來的流程！ 前後大概花了五分鐘，便簡單完成門號攜入了！
再來就等明天的流程⋯⋯
到台灣大哥大攜出 攜出流程應該和中華電信大同小異，明天預計到羅東台灣大哥大興東店辦理。
最後，到地標網通申請智慧大玩家 999 方案 接著再到羅東的地標網通，出示從台灣大哥大攜出的收據辦理後續等開通。</description></item><item><title>重灌 macOS 的工程（上）</title><link>https://www.archie.tw/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8A/</link><pubDate>Wed, 27 Sep 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8A/</guid><description>前言 幾天前，Apple 釋出了 High Sierra 的安裝檔， 一時手癢的我，便將自己的 MacBook Pro (Retina, 13-inch, Mid 2014) 來進行更新！ 早上上班前出門開始更新，晚上回到家後卻還卡在剩餘 33 分鐘處⋯⋯ 覺得詭異的我，便強制關機，而再次打開便只能 command + R 開始重灌系統。 但事情往往不會那麼簡單，在重灌系統時，一直遇上卡在剩餘 1 分鐘的進度； 使用 command + L 查看安裝記錄，便發現是一直在安裝檔的驗證失敗⋯⋯ 直到今天早上，在重灌一次，才順利完成 High Sierra 的安裝。
但故事往往都不會那麼順利 不知道為什麼的，我的 Disk password 一直輸入失敗， 但在 command + R 的修復模式之中，那組密碼是可以順利解開 Filevault 的⋯⋯ 進入到重置密碼的頁面後，跟著步驟完成後卻得到發生內部錯誤的訊息⋯⋯ 反覆試了幾次之後，得到兩個結論：
格式化硬碟再重灌看來是最快的方式 下次絕對不要輕易使用 Filevault 於是乎，花了數個小時後，便得到一台新的 MacBook Pro！
而既然都走到這步田地了，不如就順勢將自己的環境配置逐一記錄下來⋯⋯
觸控板相關 首先，第一步我都會先將觸控板相關的內容弄一弄， 這樣待會做其他事情也都會較快一些：
點一下來選按：這樣就不用真的按下觸控板才會有動作
輔助使用➡️滑鼠與觸控式軌跡板➡️觸控式軌跡板選項⋯：啟用拖移
一般 使用暗色選單列和 Dock：我個人喜歡這配色的 macOS
聲音 在選單列中顯示音量：這樣在切換聲音輸出的時候很方便，從內建揚聲器到藍牙耳機
iCloud 能勾的全勾：單純在 iPhone、iPad、以及其他 Mac 之間切換很方便</description></item><item><title>Swift 4 JSON</title><link>https://www.archie.tw/p/swift-4-json/</link><pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/swift-4-json/</guid><description>在 Swift 之中，JSON (JavaScript Object Notation) 的型別為 [String: Any]， 也就是一個 Dictionary 的概念，以一組 Key 對應一組 Value。 大多數會碰到 JSON 格式是在做網路溝通時， 使用 JSON 格式並 encode 成 Data 的型態在傳輸資料。
Swift 3 以前 我們從 URLSession.shared.dataTask 的 handler 之中， 會得到 data、response 及 error，其中的 data 會使用下面的方式才轉換成 JSON：
/* Create a Foundation object from JSON data. Set the NSJSONReadingAllowFragments option if the parser should allow top-level objects that are not an NSArray or NSDictionary. Setting the NSJSONReadingMutableContainers option will make the parser generate mutable NSArrays and NSDictionaries.</description></item><item><title>Third-party Payment</title><link>https://www.archie.tw/p/third-party-payment/</link><pubDate>Thu, 07 Sep 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/third-party-payment/</guid><description>Third-party Payment 這篇要來聊聊第三方支付，其主要的內容會介紹幾個台灣所可以使用的第三方支付方案； 而第三方支付主要解決的問題是，替我們向銀行方溝通及串接請款等動作， 讓使用者可以透過第三方支付的服務付款，而我們再和第三方支付的服務商談拆帳方式， 它可以讓我們不必親自去和銀行接洽運作的方式，只需要透過其官方的一些文件或是管理後台， 便能較輕易地處理掉金流這一塊的相關問題。 而這邊會談到下列幾間的一些資訊：
智付通 綠界 TapPay 智付通 智付寶為智冠科技旗下的金流平台公司，而智付通則是其主要的服務名稱。
會員 我們需要先到智付通的網站之中，創建一組收款帳號：
企業會員的部分，可以透過業務的接洽去談彼此之間的手續費抽成數字， 再來就可以串接其 API 來進行相關的開發動作。
支援的支付方式 超商代收 信用卡 ATM / WebATM Pay2go 電子錢包（他們自己的產品） 費用 智付通的商業模式是抽取交易手續費的模式：
其中，舉個例子： 像是信用卡一次付清 2.80% 的意思是，信用卡支付銀行本身可能是抽取 1.80%， 而智付通要賺的錢，便是 2.80 – 1.80 = 1.00 %。
備註 之前同事在串接 API 時，踩過幾次文件和實際 response 不符的雷⋯⋯
綠界 會員以及收費 綠界的個人會員和商務會員差異性，從圖表上看來只在於收款額度上的不同； 而特約會員（應該是從業務去接洽的）則是可以去談判的「依雙方議定」。
支援的支付方式 超商代收 信用卡 ATM / WebATM Apple Pay Android Pay 全家條碼立即儲 TapPay TapPay 的商業模式則和上述兩者不太相同，前面所提及的廠商， 是在每筆交易之中抽成當作手續費， 而 TapPay 則是以單筆固定金額來收取費用； 原因是在於，在使用 TapPay 時， 我們需要和相關的銀行簽妥相關文件，讓錢直接轉進我們的戶頭內， 也就是說 TapPay 實際上並不會先將錢都收進它那， 而是一個幫忙在銀行和我們之間作溝通的角色。</description></item><item><title>Credit Card Number</title><link>https://www.archie.tw/p/credit-card-number/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/credit-card-number/</guid><description>最近在串信用卡支付相關的服務，順道筆記信用卡卡號的相關規則。
驗證卡號 信用卡卡號的驗證方式是，最後一碼為驗證碼； 舉個例子來說： MasterCard – 5200 8282 8282 8210 其中最後一碼 0 是由 5200 8282 8282 821 去做一些邏輯運算後得到的結果； 也就是你其實可以前面隨便亂打，最後一碼再從 0 測試到 9 就可以通過基本的卡號驗證。
驗證方式 信用卡的驗證方式，是用 The Luhn Formula，也就是說， 當我們取得一組卡號，驗證碼產生的流程為：
去掉最後一碼（5 2 0 0 – 8 2 8 2 – 8 2 8 2 – 8 2 1） 把整串倒過來（1 2 8 – 2 8 2 8 – 2 8 2 8 – 0 0 2 5） 排序奇數的數字 x 2（2 2 16 – 2 16 2 16 – 2 16 2 16 – 0 0 2 10） 超過九的數字則 – 9（2 2 7 – 2 7 2 7 – 2 7 2 7 – 0 0 2 1） 將所有數字相加（50） 取尾數（0） 得到驗證碼為 0，則卡號 5200 8282 8282 8210 為正確的卡號格式。</description></item><item><title>Status bar style</title><link>https://www.archie.tw/p/status-bar-style/</link><pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/status-bar-style/</guid><description>Status bar style 一般在 iOS 裡頭，status bar style 可以被分成兩種
default lightContent 設定方式 我們可以在 info.plist 做全域的設定，讓整個 app 在執行的時候，都是同樣的 style； 這取決於 View controller-based status bar appearance – YES / NO 若設為 NO，則是整個 app 都會是同樣的 style； 而若設為 YES，就能在個別的 viewController 來做設定。
View controller-base status bar appearance – YES 實作方式是更改 UIViewController 底下的 preferredStatusBarStyle， 而因為它是 { get } 的，所以我們只能透過覆寫的方式來更改：
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } UINavigationController 如果你要更改的 UIViewController 是包在 UINavigationController 裡頭的話， 則需要更改的是 UINavigationController 的 preferredStatusBarStyle， 而非是當前的 UIViewController。</description></item><item><title>ViewModel with POP</title><link>https://www.archie.tw/p/viewmodel-with-pop/</link><pubDate>Fri, 11 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/viewmodel-with-pop/</guid><description>ViewModel with POP 這邊有兩個名詞需要解釋一下，一個是 ViewModel，另一個則是 POP：
ViewModel 在 iOS 的開發模式中，從你新建一個新專案的時候，它的預設內容是以 MVC 的架構為底； 而在 MVVM 的架構中，會在 View 以及 Model 之間，多夾帶一層 ViewModel 來分工。 在實作 ViewModel 的時候，我是以 structure 的方式才建構 ViewModel， 並在裡頭宣告 init(model: Model) 的方式，來將 Model 轉成 ViewModel。
struct User { var id: String var name: String var age: Int } struct UserViewModel { var title: String var content: String init(user: User) { title = user.name content = &amp;#34;Hi, 我是 \(user.name)，今年 \(user.age)歲！&amp;#34; } } POP POP（Protocol-Oriendted Programing）是以 Protocol 來傳遞的方式； 以 UITableViewCell 來說，我會建立一個：</description></item><item><title>iOS UIView shadow</title><link>https://www.archie.tw/p/ios-uiview-shadow/</link><pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-uiview-shadow/</guid><description>最近在寫的專案，使用到比較多的陰影效果，就來列列有關陰影效果的一些內容。
CALayer 陰影相關的實作方式，是以 CALayer 底下的這五個變數來控制
shadowColor: CGColor? shadowPath: CGPath? shadowOffset: CGSize shadowRadius: CGFloat shadowOpacity: Float shadowColor 預設值為不透明的黑色，我們可以透過這個參數來調整陰影的顏色。
shadowPath 預設值為 null，並支援 animated，可以在這邊調整陰影的路徑， 所以當 UIView 在透過 animated 調整大小時，我們可以一併調整 shadowPath 來跟著做變化。
shadowOffset 預設值為 [0, -3]，來調整陰影的位移。
shadowRadius 預設值為 3，系統本身會進行發散的動作。
shadowOpacity 預設值為 0，也就是完全透明； 所以如果只是要陰影，並沒有需要客製化的話， 只需要修改 shadowOpacity，畫面上就會有 offset = [0, -3], radius = 3 的不透明黑色陰影出現。
cornerRadius 這邊有點需要注意到的是，若要有 shadow 效果的話，下面兩者必須為 false
layer.masksToBounds clipsToBounds 因為若將 layer 只關閉在 bounds 的話，則無法呈現陰影的效果； 但偏偏若需要圓角效果的話，則必須更改為 true。 而這邊，我的做法是， 先建立一個透明色的 UIView，來做陰影的效果， 再疊加一層 subview 來做圓角的效果， 這樣便可以做出有陰影效果的圓角 UIView 了！</description></item><item><title>iOS User Interface Default Value</title><link>https://www.archie.tw/p/ios-user-interface-default-value/</link><pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/ios-user-interface-default-value/</guid><description>我們在開發 iOS App 的時候，對於 User interface 的開發模式有幾種流派
Storyboard Storyboard + xib xib Code 而這篇的主題，先撇除純 Code 流的開發方式，來聊聊使用 Storyboard 和 xib 的朋友，會遇到什麼事。
先說說為什麼我使用 User interface（Storyboard, xib） 一方面是因為一開始學習的時候，教學是從拉拉元件，連動按鈕開始， 比起純 Code 的寫法，這樣也讓人比較好上手； 再來便開始弄一些 Auto layout，讓畫面越來越完整。 而其中一點是，方便和設計師做討論， 看著畫面來調整 UI 會比我一直重新 Build 出 App 還快得一些。 但也正是為了讓設計師可以看到畫面，我可能得在一些 UIKit 的元件上先放置好預設的值， 好比說：
儘管這個 UIViewController 在 viewDidLoad 的時候，會再配置一次多語系的文案以及更換些 icon 或者顏色， 但至少在初步上可以看到大概會長什麼樣子。
若不清空預設值呢？ 我們就可能在部分畫面上會看到，原本打在 xib 的 UITextField 上的值（e.g Hinet CHT Auto）， 甚至是可能有些元件的 isHidden 是由程式判斷出需不需要呈現， 而畫面顯示到判斷完畢的中間，會造成畫面上元件閃現的情況。 於是原先我的做法會：
清空 xib 上的所有預設值 在 viewDidLoad 的狀態，執行清空的動作 前者的做法，會影響到的就是 xib 失去了給設計師觀看的意義， 因為全空的畫面並不符合使用者的情境； 而後者的做法，當元件一多的時候，有時便會有疏忽。</description></item><item><title>GraphQL</title><link>https://www.archie.tw/p/graphql/</link><pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/graphql/</guid><description>GraphQL v.s REST 首先，看到這個標題，要先了解一下什麼是「REST」； 我們在先前的文章中有提到關於 Firebase Database REST API 的內容， 但並沒有在文章內解釋其含義是什麼。
REST REST（Representational State Transfer），是一種架構，而非協定或是標準； 透過 HTTP 協議所提供的動作（POST、GET、PUT、DELETE）來對資源進行 CRUD（Create、Read、Update、Delete）， 並以 URI 的方式來指定資源：
POST /games：建立遊戲 GET /games：取得遊戲清單 PUT /games/123：修改 id = 123 的遊戲內容 DELETE /games/123：刪除 id = 123 的遊戲 在 iOS 開發的串接 RESTful API 的經驗中，不論是取得的資料，或是回傳回 server 的資料， 大多是以 JSON 的格式在做溝通。 前後端之間可以透過 RESTful 的方式進行明確的溝通，進而開發出相對應的功能。 REST 的缺點 但有時候還是會遇到一些問題
會拿到多餘的欄位 巢狀資源的處理 越來越多支 API 會拿到多餘的欄位
有時候我們為了顯示一個商品，在畫面上需要呈現
商品名稱 價錢 照片 URL 但可能在 GET /products/1 的時候，會拿到整個商品的資料回來：</description></item><item><title>chmod with ssh key</title><link>https://www.archie.tw/p/chmod-with-ssh-key/</link><pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/chmod-with-ssh-key/</guid><description>chmod 是由 change mode 所組成，其指令功能便是更改檔案或者資料夾底下所有檔案的權限。 而權限位是由 9 個權限位來控制，每 3 位為一組，分別為
User Group Other chmod 的八進位語法的數字說明：
r: read – 4 w: write -2 x: execute – 1 所以，舉個例子： 5 = 可讀可執行（4 + 1） 6 = 可讀可寫（4 + 2） 7 = 可讀可寫可執行（4 + 2 + 1） 那麼，chmod 600 則就代表著 User 可讀可寫，但 Group 和 Other 則無法使用。 chmod ssh key 若我們更改一下 ssh 的 private key，會發生什麼事呢？
如圖片測試結果所示，ssh 的 private key 僅能開放 User 的權限， Group 和 Other 則都不能開放，否則就會無法使用。</description></item><item><title>Firebase Database REST API</title><link>https://www.archie.tw/p/firebase-database-rest-api/</link><pubDate>Fri, 04 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/firebase-database-rest-api/</guid><description>這篇主要的內容會是簡單地記錄一下 Firebase Database RESTful API， 所提供的相關內容和使用方式。
Firebase Database Firebase database 的儲存資料方式是屬於 NoSQL 的方式， 利用一組 key 配對一組 value 的模式來建構資料庫； 而在 Database 的介面中，我們可以清楚地看到資料是以 JSON 的格式呈現。
在 iOS 開發的過程中，如果要使用 Firebase 的相關內容， 可以使用官方所提供的 Firebase iOS SDK； 或是在使用 Python 開發的時候，我會選擇使用官方推薦的 Pyrebase， 那若你目前的開發方式沒有相對應的 SDK 或是 third party 可以使用的話呢？ 那麼你就只能一起用 REST API 來完成要做的事情了！
REST API Firebase 提供了五種 Http method
GET PUT POST PATCH DELETE 其中 GET 和 DELETE 就沒什麼特別好說的，你就是取得一個 JSON 或是刪除一個。 PUT PUT 就和平常使用 PUT 的方式一樣， 它會把整個 JSON 覆蓋成你目前丟上去的 JSON。</description></item><item><title>Vapor</title><link>https://www.archie.tw/p/vapor/</link><pubDate>Thu, 03 Aug 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/vapor/</guid><description>Vapor 在 Swift 開源之後，開發者們便開始將這語言往更多層面去發展，而 web app 便是其中一項。 Vapor 是一款以 Swift 作為主要語言的 Server 建構服務，讓我們可以透過它來開發 Web 相關的應用； 對於 iOS 開發人員而言，Swift 可以用來開發 web app 是一件有趣的事情， 其代表著我們可以使用同一個語言來開發一個產品，從 server 到 client。
安裝方式 不同於在安裝 iOS 第三方套件的流程，Vapor 需要透過 terminal 來安裝相關內容： 首先，得先安裝 Vapor 的 CLI
curl -sL toolbox.qutheory.io | sh 安裝完之後，便可以在 terminal 底下使用 vapor 的指令。
建立新專案 我們可以透過下方的指令，來建立一個新專案：
vapor new ProjectName 其中第三方套件的管理方式，是使用 Swift Package Manager， 所以我們會在目錄下看到一個 Package.swift 和 Package.pins， 這方面倒是有些像 CocoaPods 所使用的 Podfile 的概念。
使用 Xcode 開發 有了專案後，你可以選擇直接打開 main.swift 來進行開發， 但如果比較喜歡使用 Xcode 開啟一個專案，而非單一檔案， 則可以透過下方指令才建立 .</description></item><item><title>Fastlane - match</title><link>https://www.archie.tw/p/fastlane-match/</link><pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/fastlane-match/</guid><description>Fastlane 是什麼？ 簡單來說，它可以替你解決除了寫程式以外的很多事情； 像是「螢幕截圖」、「打包上傳到 Testflight」、「建立 App Store 的 App 資訊」等等， 尤其是在一個專案（project）擁有多個 target 的時候， 更是只需要一行就可以打包出十幾個 App，並且分別上架到 App Store。 而在這篇文章裡頭，會介紹其中一項功能的部分用法：
Match Match 主要負責和 Certificate 相關的處理，這邊所要帶給大家的使用情境是， 一個 iOS 專案同時有需要多人同時開發，我們通常會採取的作法有下列幾種：
在 Apple Developer Team 之中加入專案各個開發人員使用自己的 Apple ID 在 Apple Developer Team 之中加入專案各個開發人員的公司 Apple ID 提供給專案各個開發人員相對應的 Provisioning Profile 第一種和第二種的做法差不多，但其壞處就是管理者無法有效地管理 Certificate， 所以有可能會時常出現一些奇怪的 App IDs 或是 iOS Provisioning Profile， 或是誰又不小心把誰的 certificate revoke ⋯⋯
所以我們需要權限劃分清楚 建議的做法是註冊一組公用的開發者帳號，不和任何人產生連結性
e.g dev@apple.com
只放這組帳號在 Apple Developer Team 裡頭，開發相關的處理皆由這組帳號來負責， 而帳號密碼無需流通到僅負責開發的人員手中； 意思是指，讓單純寫 Code 開發的人員，無須註冊特別的 Apple ID 或是加入哪個 Team， 只需要透過 fastlane match 的方式來獲得 Certificate，可以開發就好！</description></item><item><title>Socket</title><link>https://www.archie.tw/p/socket/</link><pubDate>Sat, 15 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/socket/</guid><description>最近在接觸即時通訊相關的開發內容，撇除使用第三方服務的串接， 大多數都是建議使用 Socket 來和伺服器端進行連接和溝通。 而研究了一下，在 TCP / IP 架構下，sockets 可以分為兩種
Datagram sockets(connectionless) Stream sockets(connection-oriented) Datagram sockets(connectionless) Datagram sockets 是使用 UDP 封包來進行傳送， 其主要的特色是速度快但不能保證資料的完整性以及次序有可能會有誤； 所以大多是使用在廣播資訊或是傳送一些較不是那麼重要的內容。
Stream sockets(connection-oriented) 而 Stream sockets 則是使用 TCP 封包來傳遞， 其因為會先需要確認 Server 和 Client 兩者連接狀態後再傳遞， 故速度較慢一些，但至少能確認資料的有序性以及完整度。
簡單的總結 以中華郵政的觀點來看，以結果來區分的話， 我們可以簡略地將 UDP 視為平信、TCP 視為掛號信。 而即時通訊的部分，依照上述的特色來看，就得選擇使用 TCP 的方式來進行溝通。
Server 和 Client 的溝通流程 首先，伺服器端和用戶端兩者必須使用同一類的封包才能互相通訊， 意思便是指 Server 建立了一個 UDP Socket，Client 也必須使用 UDP Socket 才能兩者打通。 而 Socket name 會需要包含 IP、Port、以及使用哪種協定； 當 Client 端的 Socket 成功聯繫上 Server 端的 Socket 時， 這兩者便形成一組 association。</description></item><item><title>多個帳號的 SSH Config 設定</title><link>https://www.archie.tw/p/%E5%A4%9A%E5%80%8B%E5%B8%B3%E8%99%9F%E7%9A%84-ssh-config-%E8%A8%AD%E5%AE%9A/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%A4%9A%E5%80%8B%E5%B8%B3%E8%99%9F%E7%9A%84-ssh-config-%E8%A8%AD%E5%AE%9A/</guid><description>一般的情形下，我們不會太需要去做 config 檔案的設定， 因為其實不太需要建立太多組的 SSH key 來增加管理上的麻煩； 但隨著身份的增加（大多數是因為工作關係）， 我們會需要用到其他組 SSH key 來連接 git server。
如果公司使用的 git server，是我原本就沒有使用的呢？ 那就沒什麼差了。 就像是我第一份工作，公司所使用的 git server 為 AWS 的 CodeCommit， 而原先我根本就不用使用到那邊的服務，所以建立一組 SSH key 在 AWS 上使用也沒什麼衝突。 且 AWS 上的教學文件，會讓你在 ~/.ssh/config 之中，以 Host 作為區別； 所以它只會在 AWS 上使用你為了 AWS 所建立的 key。
但⋯最容易發生的情形就是： 公司也使用 Github 作為組織的 git server 通常我們會有一組自己私人的 Github 帳號，若公司不反對你使用私人帳號加入組織的話， 其實你也就沒什麼差了； 但大多數的情形是會給你一組（或是請你申請一組）公司信箱的 Github 帳號， 來維護 private git repository。
Public key 我們先來看看 ssh 的 public key 裡頭，帶了哪些資訊： 重點便是最後的 xpopchi@gmail.</description></item><item><title>print</title><link>https://www.archie.tw/p/print/</link><pubDate>Fri, 07 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/print/</guid><description>print 在第一次接觸一個沒學過的程式語言時，我們多半可以看到會以「Hello, world!」作為開頭； 而你第一個所使用的 method，也很有可能就是印出東西相關的。 我在這邊寫的是 print，可能在別的語言並不是這個詞，是 printf 或是 console.log() 之類， 但這邊（或是這整個網站XD）就以 Swift 為主。
NSLog v.s print 有接觸過 iOS 開發的人，你可能也會看過別人使用 NSLog，而這邊就解釋一下兩者的差異：
NSLog 它是屬於 Fundation 的一個 function：
會加上 timestamp 會加上 identifier 會印在 device console 會花較多一些些的效能，所以會比較慢一些（因為前兩者）
print 會印在 debugger console 所以，若你只是需要記錄在 debugger console 的話，則建議就使用 print 就好。
開始使用 為了瞭解程式的執行內容，我們便開始在一些地方加上 print 的功能，像是
if a == 1 { print(&amp;#34;a 等於 1&amp;#34;) } else { print(&amp;#34;a 不等於 1&amp;#34;) } 這樣就可以在 debugger console 那看到程式目前是進到哪個判斷式裡頭， 不過他大概就很簡略地顯示
a 等於 1</description></item><item><title>Apple Pay</title><link>https://www.archie.tw/p/apple-pay/</link><pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/apple-pay/</guid><description>Apple Pay Apple Pay 已經在台灣流通一段時間，第三方支付的相關業者也相接著推出串接的服務； 而撇除串接第三方支付的 SDK， iOS 開發者本身的流程呢？
Apple developer 相關設定 首先，你需要先到 Apple developer &amp;gt; Identifiers &amp;gt; Merchant IDs 註冊一個 Identifier
新建完之後，點擊裡頭的 edit，需要補上 CSR 檔； 而如果你只是要測試這個流程，沒有要走到金流相關的測試的話，可以先跳過這段。
Xcode 相關設定 接著到你的專案裡頭，打開 Apple Pay 的開關並填入剛剛註冊的 Merchant ID。
以及 import PassKit，便可以在專案中使用 Apple Pay！
流程解釋 使用者按下 Apple Pay 的按鈕後，我們該做的流程為
建立訂單（PKPaymentRequest） 填寫訂單相關內容 建立 Apple Pay 的畫面（PKPaymentAuthorizationViewController） 設定 PKPaymentAuthorizationViewController 的 delegate present Apple Pay 的畫面 而訂單相關內容可以填寫寄送相關（ship）以及聯絡人相關（contact）和金額那些基本的。 func applePay() { let request = PKPaymentRequest() request.merchantIdentifier = &amp;#34;merchant.</description></item><item><title>JWT</title><link>https://www.archie.tw/p/jwt/</link><pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/jwt/</guid><description>JWT JWT（ JSON Web Token）和 iOS 比較有相關聯的地方， 便是在於 APNs p8 是使用 JWT 格式作為傳遞； 而有關於 JWT 的相關資料，可以參考 這個網站。 以之前所提到的 APNs 來說，是由三個部分所組成：
Header Payload Verify signature Header 在 APNs 裡頭，需要包含這兩者
alg：所使用的加密方式（algorithm），p8 是使用 ES256 作為加密方式 kid：鑰匙的 ID（key identifier） 例如： alg: ES256 kid: 12345678
Payload iss：所發送的人（issuer），這邊為開發者的 Team ID iat：所發送的時間（issued at）
Verify signature 這邊便是將上述兩者，分別做 base 64 加密後輸出成字串，再加上 p8 的 key， 一起做 ES256 加密後的結果，所以大概長這樣： {header base 64 encode}.{payload base 64 encode}.{ES256 hash[(header base 64 encode).</description></item><item><title>Wifi 密碼 – 共享密碼的平台</title><link>https://www.archie.tw/p/wifi-%E5%AF%86%E7%A2%BC-%E5%85%B1%E4%BA%AB%E5%AF%86%E7%A2%BC%E7%9A%84%E5%B9%B3%E5%8F%B0/</link><pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/wifi-%E5%AF%86%E7%A2%BC-%E5%85%B1%E4%BA%AB%E5%AF%86%E7%A2%BC%E7%9A%84%E5%B9%B3%E5%8F%B0/</guid><description>上週利用一些閒暇時間，串接一些服務寫了這個簡單的小工具， 主要為了解決每次到一間新的店家時，都得先找找 Wifi 的資訊： 找店員問、找菜單上有沒有寫、找牆壁有沒有貼⋯⋯ 於是乎想找一個地方，把我所知道的 Wifi 帳號及密碼記下來， 儘管只要連線過一次，就不會再詢問了，但至少下次人家問我的時候可以告訴他。
使用流程 打開 Wifi 密碼 – 共享密碼的平台 後，會需要使用 Facebook 做登入的動作， 其主要原因是，裡頭的資訊是由全部使用者共同維護的（共筆的概念）， 所以其實會紀錄是哪個使用者新增 Wifi 資訊，但並不會顯示出來。 為了讓使用者承擔一點點微薄的責任，來讓大家都可以比較信任 Wifi 裡頭的資訊可信度， 便加入的登入的系統。
登入畫面
接著我們會看到主畫面：
Wifi 列表
可以看到目前共筆上，有哪些 Wifi 的資訊：
名稱 地點 狀態 最後更新時間 點擊進去之後，有可能會跳出 AdMob 的獎勵型影片廣告，可以點擊連結看看當初實作的流程。 看完廣告之後才能進到內容頁面，來觀看 Wifi 密碼。 舉報無效 下方有個按鈕可以點選，便可以更改此 Wifi 資訊的狀態為「不可用」， 而目前版本會在前面的列表之中就直接篩選掉，所以並不會看到不可用的內容。 若是有人一直將你家的 Wifi 貼上來，你一直舉報也無法遏止這行為的話，請麻煩告知我⋯⋯
實作方向 – 登入 臉書的登入參照 Facebook Developer 的相關文件，先建立一個 Facebook 的應用程式； 以及利用 Firebase 的 Auth，裡頭有和 Facebook 結合的文件可以依循著做。</description></item><item><title>APNs</title><link>https://www.archie.tw/p/apns/</link><pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/apns/</guid><description>APNs（ Apple Push Notification service） 相信有在開發 iOS app 的開發者，對於這個詞應該都不會太陌生； 簡單來說，它就是推播的功能。 而推播其實有分成兩種：
Local notification Remote notification 這兩者的差異就如同名字的一般，前者是本地的通知，後者為遠端的通知。 Local notification 本地推播在 iOS 10 以後，可以參考 UserNotifications 這個 framework。 這邊附上以區域範圍為觸發條件的推播寫法： https://gist.github.com/ArchieR7/85ee0a2d8cdd652d78d6c08eebfd0fae 而鬧鐘那種概念的，或是遊戲提醒（例如遊戲的愛心已經回滿了，趕快回來玩哦！）， 這種以時間作為觸發條件的，則是設定 notification.fireDate，給它一個 Date 便會在那時候觸發。
Remote notification 遠端的推播則是如同聊天軟體常常收到的那種推播（ＯＯＯ傳送貼圖給您！）， 在 AppDelegate.swift 註冊那些的就不寫在這了～ 如果是在公司上班或者和後端合作，寫完註冊推播及回傳 deviceToken 和收到之後要幹嘛的動作， 通常就不會碰到「該如何打推播給 App」的問題，因為 iOS 只需要知道收到該怎辦XD 但總會有需要自己打推播測試、或是開發自己 app 的時候， 這邊就來談談 iOS 開發者該怎麼做！
APNs key 以往我們在產生 APNs key 的時候，是會得到一組有期限的 .p12 檔案， 其中不同的 bundle identifier 會配對到不同的 .p12 檔案； 這是一件蠻麻煩的事情，我們需要管理不同 App 的 APNs key， 上架 20 個有推播功能的 app，就需要維護 20 組 .</description></item><item><title>AdMob 獎勵式廣告實作</title><link>https://www.archie.tw/p/admob-%E7%8D%8E%E5%8B%B5%E5%BC%8F%E5%BB%A3%E5%91%8A%E5%AF%A6%E4%BD%9C/</link><pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/admob-%E7%8D%8E%E5%8B%B5%E5%BC%8F%E5%BB%A3%E5%91%8A%E5%AF%A6%E4%BD%9C/</guid><description>AdMob 在 Google 的廣告投放服務之中，是以 AdSense 作為主軸，整合所有廣告相關的服務； 而 AdMob 則是其中一個專門針對行動裝置的部分。 所以若 iOS 的開發者想在其應用上放置廣告單元，則需要從 AdMob 著手。
建立廣告單元 首先，需要先到 AdMob 的控制台中，新建一個新的應用程式， 並將 app 的相關資訊填寫完整。
再者，則是建立一個廣告單元，而這篇所要分享的是「獎勵式廣告」的實作。
什麼是獎勵式廣告？ 獎勵式廣告的意思就如其名，是一個可以在編輯時設定， 反饋給觀看玩廣告的使用者一些獎勵的一種廣告模式； 如大部分的手機遊戲，觀看影片後可以得到一些鑽石、金幣或者特殊加成等。
設定廣告獎勵 我們可以在這個畫面中，去設定使用者觀看頻率的限制以及獎勵數量。
而在後面程式實作的時候，會講解這邊設定會影響到什麼。
Framework 安裝 你可以透過 CocoaPods 或是直接下載拉進專案之中； 這邊由於我所加入廣告的 App 有整合 Firebase 的相關服務， 而 Firebase 官方並無支援 Carthage，所以在這就一併使用 CocoaPods 來做套件的管理。 因為使用 Firebase，所以只需要在原先的 Podfile 之中加上
pod &amp;#39;Firebase/AdMob&amp;#39; 並且執行 pod install，即可完成安裝。
AppDelegate.swift 先在上方 import GoogleMobileAds，並需要在 FirebaseApp.configure() 之後，加上 AdMob 的廣告設定： GADMobileAds.configure(withApplicationID: Your_Ads_ApplicationID)
import Firebase import GoogleMobileAds func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?</description></item><item><title>淺談 Android 的逆向工程</title><link>https://www.archie.tw/p/%E6%B7%BA%E8%AB%87-android-%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link><pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E6%B7%BA%E8%AB%87-android-%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid><description>Android？ 是的，這篇正是要寫有關於 Android 的逆向工程，儘管這也很可能是本站唯一一篇XD
起因 看到放在「Hack」的分類上，便可以得知，是因為想要修改遊戲參數而開始涉略⋯⋯ 提到 Android 的遊戲開發方式，我們可以簡單地分為兩種類型：
以 Java 開發 以 Unity 開發 這篇主要會以 Java 開發的遊戲作為內容分享（因為我想改的遊戲是此類型XD） 先說結論 我目前還沒有修改成功，因為這款遊戲有對 apk 進行混淆的動作⋯⋯
以至於一時之間無法找到我需要的參數來做修改⋯⋯ 不過，就先記錄一下如何走到看得到程式碼這一步！
使用到的工具
Apk tool dex2jar jd-gui Apk tool apk tool 主要負責將 .apk 拆開來，在反編譯之後，可以看到一堆 .smali 及 resource 的相關檔案， 也是負責將修改完的檔案重新包回 apk 的工具。 而由於我沒有修改任何 Code，所以只有解出 .smali 和 resource，看看裡頭有什麼東西和圖片影音檔而已。
dex2jar 和 jd-gui dex2jar 的功用在於將 .apk 轉成 .jar，配合 jd-gui 打開 .jar 來探究其 source code 內容是什麼。
流程總結 配合上述的三個工具，大概的流程應該是先以 dex2jar 和 jd.</description></item><item><title>開發人員與 UI / UX 設計師之間的合作模式</title><link>https://www.archie.tw/p/%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E8%88%87-ui-/-ux-%E8%A8%AD%E8%A8%88%E5%B8%AB%E4%B9%8B%E9%96%93%E7%9A%84%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E8%88%87-ui-/-ux-%E8%A8%AD%E8%A8%88%E5%B8%AB%E4%B9%8B%E9%96%93%E7%9A%84%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F/</guid><description>UI / UX 設計師 在工作了一段時間後，陸續接觸了幾位不同的 UI / UX 設計師， 而每個人做事的方法都有所差異，在這邊簡單地列出幾個想法。
設計師所使用的工具 在 UX 設計師裏頭，有配合過使用 Axure、Adobe Xd、或是用 Sketch 直接和 UI 一起出的。 而在 Sketch 的模式下，它裡頭有個詞叫做「symbol」，其意義和 iOS 裡頭的 UIView 相關物件相同。
物件的概念 Sketch 提供了 Symbol 的建立，讓使用者在設計時，能夠把一些重複使用到的元件，做成一個 symbol， 而它會自動定義這個 symbol 哪些值是可以被異動的：
如同上方寫的「中華電信」，便是可被異動的值，但更改這個字串並不會影響整體的外觀。
以 iOS developer 來說 設計師可以了解到，UINavigationBar 的樣貌大概是長這樣，並明白 UIBarButtonItem 能夠控制的外觀欄位有哪些，像是這邊顯示的 Edit 字串。 而設計師也可以自行建構 symbol，來增加重複使用的便利性；這點也如同我們在開發 App 一樣， 會建立一些較容易重複使用到的 UIView 來呈現畫面。 設計師可以更明確地定義物件哪些欄位是會怎麼變動的，像是一個「客製化的按鈕」， 可以先明白它的背景色可能會在其他頁面做換色、或是字體會更改， 這都可以讓開發人員在一開始設計這個按鈕時，都考慮進去來增加彈性。
維持一致性 symbol 的概念，可以維持整個專案的外觀一致性； 也就是說當設計師需要調整剛剛所說的「客製化按鈕」， 想把圓角從 5 pixel 改為 10 pixel，便只需要更改 symbol 即可， 不需要再到各個使用到相同外觀的按鈕，都去一一調整為 10 pixel； developer 也一樣，只需要更改其類別即可，省去重複定義的時間。 也可降低設計師和開發人員之間的溝通成本，讓彼此能夠更專注地做好自己的工作。</description></item><item><title>Unit test with async functions</title><link>https://www.archie.tw/p/unit-test-with-async-functions/</link><pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/unit-test-with-async-functions/</guid><description>iOS Unit test 在寫 Unit test 的時候，有時候會遇到要測試的 function 是 async 的， 但在 Unit test 的 function 之中，它本身就是走單一 thread 來決定測試結果； 若沒有多做其他處理，closure 或是其他 thread 做的事情，便不會反應到結果上。 所以我們需要告知 Unit test，要等待一下我們要測的內容。
func testAsyncFunction() { let exp = expectation(description: &amp;#34;Async Expectation&amp;#34;) NetworkManager.shared.update(data: Data(), completeHandler: { exp.fulfill() }) waitForExpectations(timeout: 30, handler: nil) } 建立一個 expectation，並在 closure 裏頭執行一些測試結果判斷， 判斷完後，補上 exp.fulfill() 來告知 waitForExpectations 可以結束等待。 這樣就可以做 async functions 的 Unit test 了！</description></item><item><title>dismiss function</title><link>https://www.archie.tw/p/dismiss-function/</link><pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/dismiss-function/</guid><description>dismiss(animated:completion:) 這個 method 對於大家而言，應該都不陌生； UIViewController 可以呼叫這個 method 來關閉，而它所關閉的概念如下： UINavigationController
UIViewController1 UIViewController2 UIViewController3 不論現在 presentingViewController 是 UIViewController 1、2、或者是 3， 在這三者呼叫 dismiss(animated:completion:) 時， 都會把 UINavigationController 的所有 viewControllers 都 dismiss。 然而一個很常的使用方式是，我們會在 UIViewController 的物件之中，自行呼叫 dismiss：
dismiss(animated: true, completion: nil) 不過這麼做的話，執行 present(, animated: , completion: ) 的 UIViewController， 就不會知道是在哪個流程或是哪個畫面 dismiss 的。 比較好的做法是，會被 present 的 UIViewController 都能透過 delegate 的方式， 告知原本的 UIViewController 「我按下了什麼按鈕」， 再由前面的 UIViewController 來決定是否 dismiss 或是做其他事。
讓整體的流程能夠得到比較好的控制，也讓 UIViewController 彼此之間的關係有個清楚的釐清。</description></item><item><title>網域相關設定</title><link>https://www.archie.tw/p/%E7%B6%B2%E5%9F%9F%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/</link><pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E7%B6%B2%E5%9F%9F%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/</guid><description>昨天，終於在 PChome 購買到 www.Archie.tw 來和大家分享一下這段經歷。 首先，從要建設這個網站的時候，就已經打算購買 Archie.tw 的網域名稱； 一來，讓人方便和我本身聯想在一塊， 二來，是為了解決這個問題：
通常在 Organization Identifier 會建議填上倒裝的網址，如 com.facebook、com.google 之類的， 而我之前私人所寫的 App，多半是隨便打⋯⋯（因為那時候沒有一個依循的地方）。
不過，當初在 PChome 要點購買時，發現其實這是有人註冊走的⋯⋯ 但還好，它的期限剛好最近會到期（2017-05-12）。 想當然耳，我便是在等到 5 月 12 日時，馬上前往去註冊，深怕自己錯過！ 只是上頭的文字依舊是 2017-05-12 過期，並且還是之前那個人的相關資訊， 意思就是說其實網域是還沒被釋放出來的⋯⋯
於是便去查詢了相關的資訊，原來網域到期後，會有一段贖回期和釋放期， 原先註冊的人可以在那段時間贖回其網域； 以 .tw 來說，贖回期為 30 天、刪除期為 3 天， 於是乎 2017-05-12 到期的這個網域，其實我得等到 33 天後的 2017-06-14 才能註冊。
而就在昨日（2017-06-14）中午時，再更新一次購買的網頁，便發現可以註冊了！ 費用為 800 元 / 一年，透過線上刷卡的方式解決了這一個多月來的網域問題！ 等付款過後的一、兩個小時內，便可以設定 DNS，將原先 vultr 上的 IP 設定進去， 就可以透過 Archie.tw 連到 vultr 的機器了～
另外，vultr 以及 WordPress 都需要做相關的設定，將原先顯示 IP 的地方， 都更改為剛剛獲得的網域名稱，並順道設定 https 的問題。</description></item><item><title>KVOController</title><link>https://www.archie.tw/p/kvocontroller/</link><pubDate>Tue, 06 Jun 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/kvocontroller/</guid><description>KVOController 有關 Observe 的相關做法，在 Swift 上我會選擇使用 RxSwift，那 Objective-C 呢？ 在這邊簡單介紹一下 KVOController 的 solution 給 Objective-C 的開發者。 在 NSObject 的子類別下，都會繼承到一個 FBKVOController 的物件，名字為 KVOController； 而這邊要使用的 method 是這個：
(void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block; object 是我們要觀察的物件 keyPath 是 object 底下的要觀察的值，它的名稱（key） options 則是填入 NSKeyValueObservingOptions block 再來決定當 object 的 keyPath 那物件有更動時，要做些什麼事
舉個例子 [self.KVOController observe:self keyPath:NSStringFromSelector(@selector(observeObjectName)) options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&amp;lt;NSString *,id&amp;gt; * _Nonnull change) { //do something }]; observe:self keyPath:NSStringFromSelector(@selector(observeObjectName)) 翻成白話文就是 self 去觀察 self.</description></item><item><title>Optional</title><link>https://www.archie.tw/p/optional/</link><pubDate>Tue, 23 May 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/optional/</guid><description>前言 Optional 正如其名，就是個可選擇或者說是可有可無的意思。
Optional 在 Swift 的開發過程之中，我們可以看到「 ! 」、「 ? 」存在於變數之後，像是 var userName: String? 正式意味著 userName 這個 String 有可能是 nil。 有關 Swift optional 的解釋和 nil 對於 Swift 的介紹可以看看這篇，由小草哥所攥寫的文章。 這邊要補充的是，在 Objective-C 裏頭，則是使用 nonnull 和 nullable 來代表著 Swift 裡頭的「 ! 」、「 ? 」。 而在 Objective-C 之中，可以使用 NS_ASSUME_NONNULL_BEGIN 及 NS_ASSUME_NONNULL_END 來作為區域性的宣告 @property 的屬性為 nonnull；若其中有需要宣告成 nullable 的，則再補上即可。
NS_ASSUME_NONNULL_BEGIN @interface DemoObject : NSObject @property (nonatomic) NSString *name; @property (nonatomic, nullable) NSString *address; @property (nonatomic, readonly) NSString *phoneNumber; @end NS_ASSUME_NONNULL_END</description></item><item><title>七天學會設計模式 - Facade</title><link>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-facade/</link><pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-facade/</guid><description>Facade 其實 Facade 的概念簡單來說，就是簡化使用物件方的介面。 舉個例來說，我建立了一個 Calendar 的 UICollectionView，可能裡頭會需要很多的邏輯判斷；像是「計算 Cell 的 Size」、「判斷日期是否為假日」、「判斷月份」⋯⋯等，但使用這個物件的人，基本上不需要（也不應該）去煩惱這些事情。 如同我們吹電風扇，只需要「強、中、弱、關」的使用介面，並不需要知道它內部是調整不同的功率去達到這效果，但對使用者而言並不是那麼的重要。 而在 MVC 的架構底下便是如此，使用者只需要 ViewController 上可以操作的 function 即可，底部的 Model 是如何操作以及邏輯運算如何，就相對的沒那麼重要，丟給系統去做就好！ 所以在 Facade 的設計模式下，每個物件的介面需要被規劃過，哪些需要使用 private、fileprivate、class 等，適時地分配各個變數或常數及方法的使用權限。</description></item><item><title>七天學會設計模式 – Observe</title><link>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-observe/</link><pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-observe/</guid><description>訂閱 有使用過網誌或是一些新聞類型的網站時，通常可以在旁邊看到「訂閱」的按鈕，接著點擊下去後就可以在作者有發動或異動文章時，收到通知。
Observe 這個設計模式的概念類似於「訂閱」的功能，我們會去「訂閱」某個物件，當它做了某些事情或者其值改變時，可以去做相對應的動作。
應用 舉個比較常會遇到的案例：鍵盤 我們通常會希望在鍵盤升起來時，調整我們的畫面，看是移動 View 的 frame，或是設定 TableView 的 ContentOffset 之類的。 而大多數採取的方式是「監聽」 NotificationCenter 的「鍵盤升起」的事件，所以當「鍵盤升起」時，我們可以做相對應的處理；而當「鍵盤收起」時，我們也可以執行另一段 function。 這，便是 Observe 的設計模式。 我們去「訂閱」或者「監聽」某個事件，像是 Value changed 或是某個 function 被呼叫，來做相對應的處理。
第三方套件 RxSwift、ReactiveCocoa 便都是圍繞在 Observe 設計模式的框架，來做響應式的開發。
響應式開發 如名稱所述，意思是指當 Model 或者 ViewModel 的狀態（值）更動時，畫面可以很即時地跟著變動。 對 RxSwift 有興趣的人，可以看看這篇文章 線上讀書會 RxSwift 分享。</description></item><item><title>Weak</title><link>https://www.archie.tw/p/weak/</link><pubDate>Fri, 05 May 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/weak/</guid><description>在 iOS 的開發語言之中，不論是 Objective-C 或者 Swift，你或許都有看過這個詞
weak 你可能會知道它可以避免 retain cycle，但其背後的觀念是什麼？
ARC 在目前大家所熟悉的開發環境之中，記憶體的管理是由 iOS 或 macOS 自行去解決的；它會在你宣告或者呼叫物件的時候，替它在計數器上 +1，而當你用不到時，便會 -1。 當計數器為零的時候，便釋放掉這個物件的記憶體位置。 舉個例子，我在某個 ViewController 裏頭，宣告了一個變數 A 及執行一個異步的閉包（closure），並在裡頭使用到 A。 此時，A 在剛剛宣告產生的時候，計數器會是 +1，而在閉包內被使用到，故計數器會再 +1，所以在閉包執行時，它會是 2。
那如果我們這時候，離開了 ViewController，照理說其裡頭的 instance 應該都要被釋放記憶體位置；但因為異步閉包的關係，我們無法確定在離開的時候，異步閉包是否在其他執行緒中正在執行，造成 A 的計數器仍為 1，且會繼續執行異步閉包的內容。
weak 簡單來說就是，它並不會讓這個物件在計數器上 +1，並且在記憶體被釋放之後，指標會指向 nil；而在 Objective-C 及 Swift 裏頭，nil 的物件呼叫方法時，是不會造成崩潰的。
retain cycle 就像是 A 使用到 B，並且 B 也使用到 A，兩者互相幫對方在計數器上 +1，那僅管我們今天離開了這個畫面，系統幫 A – 1 之後，仍然會因為 B 有使用到它，故釋放不掉 A，而 A 有使用 B，所以 B 也釋放不掉。（很饒舌，我知道） 所以在 A 裡頭使用到 B 時，將 B 宣告成 weak B，便不會幫 B 在計數器上記上一筆；當 A 要被釋放掉的時候，也不會因為 B 使用 A，而釋放不掉。</description></item><item><title>502 Bad Gateway Error with nginx</title><link>https://www.archie.tw/p/502-bad-gateway-error-with-nginx/</link><pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/502-bad-gateway-error-with-nginx/</guid><description>源頭 在攥寫七天學會設計模式 – Singleton時，發生了點小狀況。 我點擊 WordPress 的「全部文章」時，顯示 502 Bad Gateway 的錯誤訊息； 由於點下去後不久（一、兩秒內）就跳轉出錯誤，故猜測不是 timeout 的關係， 便開始了一段 debug 的故事⋯⋯
環境 我是使用 WordPress（不是重點）的框架，並架設在 Vultr 的主機上； 主機的主要規格為 CPU 1 vCore、RAM 1024 MB、25 GB SSD。
原因 透過 nginx 的 error log（cat /var/log/nginx/wordpress_https_error.log）， 發現關鍵字： upstream sent too big header while reading response header from upstream 拿去餵狗的結果是，需要調整 nginx.conf（vim /etc/nginx/nginx.conf）， 加上
http { proxy_buffer_size 128k; proxy_buffers 4 256k; proxy_busy_buffers_size 256k; fastcgi_buffer_size 128k; fastcgi_buffers 4 256k; fastcgi_busy_buffers_size 128k; ... } 來調整 buffer size，來避免資源不足直接捨棄的情況（502）。 由於 5 塊美金的方案，Vultr 僅提供 1024 MB 的記憶體大小，但它有 25 GB 的 SSD！ 故可以透過 Swap 的方式，用硬碟換取記憶體的效能。</description></item><item><title>工作一年半的一些心得分享</title><link>https://www.archie.tw/p/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</link><pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</guid><description>前言 前陣子在 PTT MacDev 版寫了篇心得，這邊就轉載過來
正文開始 各位好，這篇文章主要是給新手一些方向和想法～ 純屬個人的經歷和看法，可以一起以輕鬆的態度聊聊～ 我個人是在 2015 年中開始接觸 iOS 的開發，以 Objective-C 為一開始自學方向。 從簡單遊戲開始下手，像是猜數字、圈圈叉叉之類的， 練練基本的拉拉 UI、認識Storyboard、.h 的宣告、.m 的實作等。 接著剛好 Xcode 7 開始讓免費的開發者可以裝 App 至實體裝置上， 發現自己原本都用 4.7 吋的模擬器執行，而到了 5.7 吋的裝置上時， 會有跑版的問題，於是花了一些時間學習 AutoLayout。 而基本上 AutoLayout 有個概念熟悉即可， 除非是比較特別的效果需要思考一下彼此之間的 priority， 不然一般 App 都還蠻輕易解決這方面的問題； 而比較有趣的是，像在 ScrollView 裏頭做 AutoLayout 時， 要有 contentSize 的概念，而不要輕易的點「讓系統補完 constraints」的按鈕。
接著，在我準備面試前的一兩個月，加入了一些 iOS 的開發社群 （e.g iOS @ Taipei、Cocoaheads Taipei等） 厚著臉皮加了版上比較活躍的幾位前輩，並詢問他們一些問題和方向， 於是開始練習其他實作：
氣象資料開放平臺： 練習接 Api，當時我是寫了一個去接目前各雨量觀測站的 App， 篩選 10 分鐘內有偵測到雨量的， 並在 MapView 上放上大頭針，顯示當區目前雨量。 （AFNetworking、MapKit）</description></item><item><title>線上讀書會 RxSwift 分享</title><link>https://www.archie.tw/p/%E7%B7%9A%E4%B8%8A%E8%AE%80%E6%9B%B8%E6%9C%83-rxswift-%E5%88%86%E4%BA%AB/</link><pubDate>Thu, 23 Feb 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E7%B7%9A%E4%B8%8A%E8%AE%80%E6%9B%B8%E6%9C%83-rxswift-%E5%88%86%E4%BA%AB/</guid><description>線上讀書會 RxSwift 分享</description></item><item><title>Privacy Policy</title><link>https://www.archie.tw/p/privacy-policy/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/privacy-policy/</guid><description>This Privacy Policy governs the manner in which Archie collects, uses, maintains and discloses information collected from users (each, a &amp;ldquo;User&amp;rdquo;) of the https://www.Archie.tw website (&amp;ldquo;Site&amp;rdquo;).
Personal identification information We may collect personal identification information from Users in a variety of ways, including, but not limited to, when Users visit our site, register on the site, and in connection with other activities, services, features or resources we make available on our Site.</description></item><item><title>七天學會設計模式 - Singleton</title><link>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-singleton/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.archie.tw/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-singleton/</guid><description>前言 最近和同事一起購入七天學會設計模式，不過書中是以 Java 作為示範語言； 而這邊，我會以 Swift 及 Objective-C 來攥寫範例並補充些內容。
Singleton 如同它的命名一般，在整個 App 運作時，僅會有一個 instance。
Swift Swift 宣告 Singleton 的方式很簡單，就是在 class 底下宣告一個 static 的常數（constant）。
class SingletonDemo { static let shared = SingletonDemo() } Objective-C 而 Objective-C 底下，我們要注意一些事情； 在 Multi-Thread 的情況下，我們得避免同時有多個 thread 執行建立 instance，故在創建時，必須使用 dispatch_once_t 來確保僅會有一個 thread 執行。
#import &amp;lt;UIKit/UIKit.h&amp;gt; @interface SingletonDemo : NSObject + (instancetype)shared; @end #import &amp;#34;SingletonDemo.h&amp;#34; @implementation SingletonDemo + (instancetype)shared { static SingletonDemo *instance = nil; static dispatch_once_t once_token; dispatch_once(&amp;amp;once_token, ^{ instance = [[SingletonDemo alloc] init]; }); return instance; } @end 學會了如何創建 Singleton 之後，可以想想哪些物件適合以這種方式創建； 如「目前登入的使用者」，正是可以用 Singleton 的方式做設計，畢竟一個 App 同時僅能有一位使用者登入，是大多數軟體的設計，而這恰巧符合 Singleton 的精神。</description></item></channel></rss>