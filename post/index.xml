<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Archie</title>
    <link>https://example.com/post/</link>
    <description>Recent content in Posts on Archie</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Markdown 嵌入 YouTube</title>
      <link>https://example.com/p/markdown-%E5%B5%8C%E5%85%A5-youtube/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/markdown-%E5%B5%8C%E5%85%A5-youtube/</guid>
      <description>前言 一般來說，我們都可以直接使用 YouTube 的嵌入程式碼來直接加入影片，而今天如果要在 Markdown 裡頭製作這段這程式碼的話，我們可以怎麼做？
嵌入的程式碼 &amp;lt;iframe width=&amp;quot;560&amp;quot; height=&amp;quot;315&amp;quot; src=&amp;quot;https://www.youtube.com/embed/OyCN04p-uS8&amp;quot; title=&amp;quot;YouTube video player&amp;quot; frameborder=&amp;quot;0&amp;quot; allow=&amp;quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&amp;quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt; Markdown 其實就只有一個重點，就是得到影片的 ID；這個你可以從很多地方取得，以線上讀書會 RxSwift 分享來說
首先就是先取得縮圖的 URL，格式為
   URL Description     https://img.youtube.com/vi/VIDEO_ID/0.jpg Full-size thumbnail   https://img.youtube.com/vi/VIDEO_ID/1.jpg Small thumbnail images   https://img.youtube.com/vi/VIDEO_ID/2.jpg Small thumbnail images   https://img.youtube.com/vi/VIDEO_ID/3.jpg Small thumbnail images   https://img.youtube.com/vi/VIDEO_ID/default.jpg Default thumbnail image   https://img.youtube.com/vi/VIDEO_ID/hqdefault.jpg High-quality default thumbnail image   https://img.</description>
    </item>
    
    <item>
      <title>Archie 的斜槓紀錄 2019-08</title>
      <link>https://example.com/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2019-08/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/archie-%E7%9A%84%E6%96%9C%E6%A7%93%E7%B4%80%E9%8C%84-2019-08/</guid>
      <description>這篇是什麼？ 這篇文章的內容並不會圍繞 iOS 或是 Swift 等，而是投資理財的部分，其中並不會有什麼教學或是分析，單純只是我這個月的損益總結而已。
2019 年 8 月份總結 Adsense 其實我一直沒有在看這方面的收入，不過看來要加把勁在廣告上才是💪 大多數都是從一、兩個我沒有在維護的 App 來的⋯⋯ 九月份會開始掛上網站的廣告和看能不能在 iOS 13 正式版上線的時候， 將一個由 SwiftUI + Combine 所編寫的 side project 弄上架💦
 
Bitfinex 我有在 Bitfinex 搭配 Coinlend 進行放貸，並在 8/9 加碼了 $ 50,000 元進去 八月份的報表大概如下   共獲利了 USD $ 31.68
台股股利 這個月領了三次股利，共計 $ 1,596 元
八月份總收入  Adsense USD $ 1.33 Bitfinex USD $ 31.68 台股股利 $ 1,596 元  共計 $ 2,629.87 元</description>
    </item>
    
    <item>
      <title>在 SwiftUI 處理中文輸入法所會遇上的問題</title>
      <link>https://example.com/p/%E5%9C%A8-swiftui-%E8%99%95%E7%90%86%E4%B8%AD%E6%96%87%E8%BC%B8%E5%85%A5%E6%B3%95%E6%89%80%E6%9C%83%E9%81%87%E4%B8%8A%E7%9A%84%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%9C%A8-swiftui-%E8%99%95%E7%90%86%E4%B8%AD%E6%96%87%E8%BC%B8%E5%85%A5%E6%B3%95%E6%89%80%E6%9C%83%E9%81%87%E4%B8%8A%E7%9A%84%E5%95%8F%E9%A1%8C/</guid>
      <description>最近開始在嘗試把玩 SwiftUI 並打算作為一個 side project 的主要 UI 編寫方式，這篇文章則是其中一個使用情境所遇上的困難處。
開發環境  Xcode 11 Beta 7（但顯示為 Beta 6 - 11M392r ） macOS Catalina - 19A546d iOS 13.1 Beta  記錄這點蠻重要的，因為可能過個幾版這篇文章就沒參考價值了😂 還沒有下載更新的朋友，可以快去更新一下！
使用情境 我要來做一個搜尋的功能，讓使用者可以輸入關鍵字，並自動搜尋完後將結果呈現在下方👏
於是我們可以用兩個 UI 元件來達成這件事
 TextField List 並寫一個 @Binding var 或是 @ObservedObject var 來讓 TextField 的 text 有個 binding 的地方，當它的值有更新時，觸發搜尋的動作🚀 而搜尋完的結構再來更新畫面上的 List。  聽起來沒什麼毛病，對吧？
實際上你會遇上的問題⋯ 當你想和我一樣，用拼音的輸入方式時；不論是你拼音還是注音，當你按下第一個音時，便會跑一次上述的流程了⋯⋯ 而我們所期望的流程應該是使用者選完字後再進行搜尋，這點在目前的 TextField 是做不到的，因為它不會判別目前是否有還沒拼完音的狀況就發動了。
那該怎麼辦呢？  喵神這麼說 
你可以查看一下當時的相關推文
我的作法就是以 UIViewRepresentable 來包裝，詳細的程式碼可以到 GitHub 查看👍
成果 當輸入了 luo dong 但是還沒選字的話並不會有動作。</description>
    </item>
    
    <item>
      <title>建立 Xcode 的檔案範本</title>
      <link>https://example.com/p/%E5%BB%BA%E7%AB%8B-xcode-%E7%9A%84%E6%AA%94%E6%A1%88%E7%AF%84%E6%9C%AC/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%BB%BA%E7%AB%8B-xcode-%E7%9A%84%E6%AA%94%E6%A1%88%E7%AF%84%E6%9C%AC/</guid>
      <description>什麼是範本？ 在新增檔案的時候，會有預設的這幾種類型可以選擇；而當我們有一些自己常用的架構，如 Coordinator、ViewModel 等，可以自建一個範本來使用。 下面舉例幾個預設的 Swift 檔案
Swift File 位置在 /Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Swift File.xctemplate
//___FILEHEADER___ import Foundation SwiftUI View 位置在 /Applications/Xcode-beta.app/Contents/Developer/Library/Xcode/ExtraTemplates/File Templates/User Interface
//___FILEHEADER___ import SwiftUI struct ___FILEBASENAMEASIDENTIFIER___ : View { var body: some View { Text(/*@START_MENU_TOKEN@*/&amp;#34;Hello World!&amp;#34;/*@END_MENU_TOKEN@*/) } } #if DEBUG struct ___FILEBASENAMEASIDENTIFIER____Previews : PreviewProvider { static var previews: some View { ___FILEBASENAMEASIDENTIFIER___() } } #endif 這些是跟著 Xcode.app 走的，而若是我們使用者自定義要使用的，得放在 /Users/UserName/Library/Developer/Xcode/Templates 先建立一個資料夾，或是可以到上述的位置複製一份過來。 需要至少三個檔案
 FILEBASENAME.swift TemplateIcon.png TemplateInfo.plist  我自己的使用方式是複製系統的 Swift file 來做修改 🔧 也比較好去熟悉可替換文字和 header 的使用方式 👍</description>
    </item>
    
    <item>
      <title>Get ETH balance and tokens balance</title>
      <link>https://example.com/p/get-eth-balance-and-tokens-balance/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/get-eth-balance-and-tokens-balance/</guid>
      <description>前言 最近都在處理區塊鏈相關的問題，其中一個就是怎麼直接透過節點（****.infura.io）來取得 ETH 和其他 ERC-20 的地址餘額（balance）。
JSON RPC ETH 節點所使用的 request body 是依照 JSON RPC 的方式，也就是我們所使用的 request path 都是相同的，像是主要的 https://mainnet.infura.io ；不同的是，我們可以透過不同的 body 內容來區別不同的需求。
基本的 body 格式 { &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;method name&amp;#34;, &amp;#34;params&amp;#34;: [], &amp;#34;id&amp;#34;: 1 } 取得 ETH 餘額 取得 ETH 餘額的方式較為單純，節點有提供一個 method 是 eth_getBalance，使用起來如下
{ &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: &amp;#34;eth_getBalance&amp;#34;, &amp;#34;params&amp;#34;: [&amp;#34;你的 ETH 地址&amp;#34;, &amp;#34;latest&amp;#34;], &amp;#34;id&amp;#34;: 1 } 其中這邊的 latest 意思是指向最新的那個區塊取資料的意思；
我們便可以得到 response：
{ &amp;#34;id&amp;#34;:1, &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;result&amp;#34;: &amp;#34;0x0234c8a3397aab58&amp;#34; // 158972490234375000 } 其中注意到一點是，result 所回應的是你這個地址有幾聰的 hex 字串，所以當我們取得的時候得注意一下。</description>
    </item>
    
    <item>
      <title>BIP-39 Mnemonic validate</title>
      <link>https://example.com/p/bip-39-mnemonic-validate/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/bip-39-mnemonic-validate/</guid>
      <description>前言 最近處理了一些加密貨幣的問題，其中一個是助記詞的驗證，這邊將會解釋助記詞的生成和驗證方式。
生成助記詞 首先我們這邊所介紹的是助記詞生成方式，先建立一個 128 bytes 的隨機序列，也就是隨機產生 16 個 UInt8 的序列；
主要有分成 128、160、192、224、256 bits（每 32 bits 做為一個區間），而下列會以 128 bits 作為流程解釋。
對隨機序列加密（SHA256） 我們對剛剛所產生的序列做 SHA256 加密，便會得到由 32 個 UInt8 所組成的 Array。
Checksum 用來驗證助記詞是否正確的方式是透過 Checksum 來辨別，而 Checksum 的 size 為序列的長度 / 區間，如我們這邊所提及的 128 / 32 = 4；
意思便是剛剛所加密完的序列，我們取前面 4 bytes 的數值當作 checksum。
產生助記詞 而剛剛的隨機序列（128 bits）加上 4 bits 的 checksum 組成 132 bits，接著我們每 11 bits 作為一個分隔，也就可以得到 132 / 11 = 12 個數字。
而每 11 bits 作為一個分隔的意思也意味著數字的區間落在 0 – 2047 之間，也就是為什麼 12 字的助記詞所支援的單字庫數量為 2048。</description>
    </item>
    
    <item>
      <title>Change login shells without chsh</title>
      <link>https://example.com/p/change-login-shells-without-chsh/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/change-login-shells-without-chsh/</guid>
      <description>前言 最近心血來潮更新了 brew，其中我正在使用的 shells – zsh 也一併更新了，才發現當初在從 bash 轉到 zsh 的時候有指定到版號的部分⋯也就是長得像這樣
/usr/local/bin/zsh-5.6.1 而 zsh 一更新之後，我的 iterm2 便很合理地打不開，因為找不到 login 的 shells； 當初我是在 bash 裡頭使用 chsh 來變更
chsh -s $(which zsh) 如今打不開 iterm2 該如何更改呢？
使用者與群組 首先先到 使用者與群組
並先解鎖來得到更改的權限
就可以按住 control 並點擊使用者，就會出現 進階選項 可以選擇
最後就可以在 登入 shell 那欄更改即可！</description>
    </item>
    
    <item>
      <title>Resign .ipa</title>
      <link>https://example.com/p/resign-.ipa/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/resign-.ipa/</guid>
      <description>前言 我們都知道 iOS 是使用 ipa 檔案來安裝 app，而該如何換掉 ipa 裡頭的憑證呢？
解壓縮 首先，我們先將 Application.ipa 解壓縮，可以得到一個 PayLoad 的資料夾，裡頭包含著一個應用程式 Application。
移除舊有的簽章 接著我們透過 terminal 來進行移除的動作
rm -rf PayLoad/Application/_CodeSignature 找出你打算簽章的 provisionprofile
你可以透過 Apple developer 的網頁直接下載，或是查看本機裡頭的檔案，路徑會是在： ~/資源庫/MobileDevice/Provisioning Profiles/ 用 Finder 到那路徑之後，可以使用空白鍵來進行預覽， 透過名稱以及 SHA-1 來辨別。
嵌入 mobileprovision 到 app 之中 接著就複製並改名字放入 app 中
cp yourProvisionProfile.mobileprovision Payload/Application.app/embedded.mobileprovision 來製作簽章所需要的 entitlements.plist 先將 .mobileprovision 輸入成 profile.plist
security cms -D -i yourProvisionProfile.mobileprovision &amp;gt; profile.plist 再來利用 profile.plist 輸出成 entitlements.plist
/usr/libexec/PlistBuddy -x -c &#39;Print :Entitlements&#39; profile.</description>
    </item>
    
    <item>
      <title>CoreData with background task</title>
      <link>https://example.com/p/coredata-with-background-task/</link>
      <pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/coredata-with-background-task/</guid>
      <description>前言 雖然在 iOS 上開發了幾年的時間，但一直到最近才開始使用 CoreData；之前在第一份工作的專案之中是使用 FMDB 來處理資料存取，而後續則是用了 Realm。
選擇的原因分別是當時 FMDB 的速度較其餘兩者快速，而後來看上 Realm 的跨平台特色，不過近期開發的感想是能以原生為主的話，就儘量降低對於第三方套件的依賴性。
這篇文章會記錄些什麼 其實這篇文章並不會從頭到尾寫下教學，而把重點放在一些我踩到的雷上，像是⋯⋯
記得要附上 sqlite 的路徑 原先我的 persistentContainer 的產生方式如下
lazy var persistentContainer: NSPersistentContainer = { let container = NSPersistentContainer(name: &amp;#34;OfflineWallet&amp;#34;) let description = NSPersistentStoreDescription() description.shouldInferMappingModelAutomatically = true description.shouldMigrateStoreAutomatically = true container.persistentStoreDescriptions = [description] container.loadPersistentStores { _, error in if let error = error { fatalError(&amp;#34;Unresolved error \(error), \(String(describing: error._userInfo))&amp;#34;) } } return container }() 在模擬器上存取了幾次，每次都有 save 且第二次進入畫面的時候，都可以 fetch 得到資料，但是只要重開 App 就會從頭來過⋯⋯</description>
    </item>
    
    <item>
      <title>SwiftLint</title>
      <link>https://example.com/p/swiftlint/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/swiftlint/</guid>
      <description>SwiftLint 去年（2018）年末的時候，在 Twitter 上看到一些朋友們在討論著 SwiftLint 的使用，於是便也嘗試在目前公司的專案中導入，來解決 Coding Style 的問題。
Coding Style 的問題 剛進入到這家公司時，最痛苦的事情莫過於毫無章法的 Coding Style，這部分就不一一細數了，詳情可以看前陣子我的 Twitter 動態。
專案裡頭每個人寫的格式不同，會造成其他人在閱讀專案時，大幅增加理解彼此想法的成本
 簡單來說就是浪費一堆時間在猜你在寫什麼
 為了讓專案裡頭的大家有差不多的 Coding Style，可以選擇使用 SwiftLint 來處理這個情況。
實際嘗試 首先先以 SwiftLint 的官方教學來安裝和建構環境，並利用 Ethan 的 SwiftLint rules 當作基底來調整，先以別人的規範來看看差異性。
一跑下去便是直接噴了 3000+ issues⋯⋯
可以透過 Rules.md 來逐條看看定義並透過 example 來看怎麼算是 Non Trggering 和 Triggering；再來一條一條調整改進。
一些心得 目前公司的專案從 3000+ ➡️ 17 warings，而這 17 條是我還沒 refactor 到的 features，所以就還沒那麼急著去調整。
private_outlet 和 private_action 而其中一條規則 private_outlet 給我的感觸挺深刻的，由於我大多數的工作經歷是獨立開發居多，而每個 IBOutlet 都必須為 private 是第一份工作時所踩到的坑；當時公司共有兩位 iOS 工程師，彼此皆為 Junior 的程度，故沒什麼規範和概念，於是便會出現一些神秘的情境⋯⋯</description>
    </item>
    
    <item>
      <title>AWS EC2 with WordPress</title>
      <link>https://example.com/p/aws-ec2-with-wordpress/</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/aws-ec2-with-wordpress/</guid>
      <description>前言 Vultr 這個網站原本是在 Vultr 上開一台機器，每個月大概的費用為 USD $6 – 7 元之間，並利用 Certbot 自動更新 SSL 憑證。但後來發現不太會維護那台機器，時常因為記憶體造成資料庫錯誤，每隔兩三天就得去手動重新啟動來解決問題，乾脆就搬家到 WordPress.com 的服務。
WordPress.com 而 WordPress.com 的好處就是全部幫你處理好好的，然後我使用的是個人版的方案；NT$ 130 / 月，便有提供轉址的功能和一年份免費的網域。不過由於我自己是向 PChome 買 Archie.tw，所以主要是為了轉過去而付費。
但使用服務和自己開一台機器的差異性就在於彈性，像是安裝外掛便被放在商務版的功能之中，而費用為 NT$ 799 / 月。
這樣一用也用了一段時間，直到近期註冊了 AWS 的服務，便決定搬移到 AWS 上。
AWS 在 AWS 上新註冊的用戶可以擁有一年的免費方案，而這個網站目前使用到幾個 AWS 服務分別為
 EC2 Load Balancer Certificate Manager Route 53  這邊來介紹我的流程：
Key Pairs 首先我們先到 EC2 的頁面選擇 NETWORK &amp;amp; SECURITY ➡️ Key Pairs 來建立一組 Key pair，用於之後連接到 EC2 instance
EC2 透過 AWS Markeyplace 開一台新的 instance，使用 WordPress Certified by Bitnami 搭配 t2.</description>
    </item>
    
    <item>
      <title>POSTMAN – Pre-request script</title>
      <link>https://example.com/p/postman-pre-request-script/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/postman-pre-request-script/</guid>
      <description>POSTMAN 除了可以發送 request 到 server 之外，也有提供 pre-request script 的功能，讓我們可以撰寫 script 來進行一連串的測試。 舉個例子，我們有三支 API，邏輯為 名稱（Request body）【Response body】：
 登入（帳號、密碼）【Token】 取得使用者的消費紀錄列表（Token）【Array】 取得單筆消費紀錄（Receipt ID）【Receipt】  在沒有撰寫 pre-request 之前若要取得 Receipt 的話，我們得要先呼叫 登入，接著手動複製 Token 到 取得使用者的消費紀錄列表 的 request body 裡頭，然後再複製⋯⋯（你們應該懂） 這邊就來教教如何先寫好 script，之後只要按最後你想得到的那支 API 就行了！
let account = &amp;#39;account&amp;#39; let password = &amp;#39;password&amp;#39; let index = 0 pm.sendRequest({ url: &amp;#39;https://Archie.tw/login?account=&amp;#39; + account + &amp;#39;&amp;amp;password=&amp;#39; + password, method: &amp;#39;get&amp;#39; }, function(err, response) { let token = response.json().token; pm.</description>
    </item>
    
    <item>
      <title>Info.plist localized</title>
      <link>https://example.com/p/info.plist-localized/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/info.plist-localized/</guid>
      <description>一些需要權限的功能都會需要在 Info.plist 裡頭加上說明，而這個說明要實作多語系則是建立一個 InfoPlist.strings（沒錯，名字就是這樣） 然後對相對應得 Key 填寫翻譯，像是：
NSLocationWhenInUseUsageDescription = &amp;quot;說明填寫&amp;quot;; 就可以在要使用位置的說明處顯示多語系的結果了。
至於其他的 Key 可以從 CocoaKey 官方文件以及 CoreFundationKey 找找。</description>
    </item>
    
    <item>
      <title>Git submodule</title>
      <link>https://example.com/p/git-submodule/</link>
      <pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/git-submodule/</guid>
      <description>有些時候，我們會需要幾個檔案和其他專案共用，而 iOS 的專案可以採取 CocoaPods / Carthage，但如果是要和其他語言共用的話該怎麼辦呢？
舉個例子，Server 和 Client 之間傳遞 Status Code，像是 code: 20000、20001、20002 之類的，收到 code 後要再做後續動作。
不過一份 Code 的定義散落在多個平台 / 專案之中，難免會有人雷的時候；不論是 client 記錯或是 server 回錯，而若是有個地方可以共同維護的話，便可以減少這種失誤。
所以就把那些文件（e.g .json）放到 repository 上，然後在你的專案之中：
git submodule add YourDocumentRepository.git 就會在你的專案資料夾中看到 clone 下來的結果，接著再將檔案拖拉至專案之中即可使用。 若要更新 submodule，則下
git submodule update 或是到 clone 下來的資料夾
git pull 像是如果懶得在每一個檔案都 import PodName，就直接弄成 Submodule 的方式來處理也行！</description>
    </item>
    
    <item>
      <title>Create CocoaPods by yourself</title>
      <link>https://example.com/p/create-cocoapods-by-yourself/</link>
      <pubDate>Sat, 15 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/create-cocoapods-by-yourself/</guid>
      <description>這篇文章會介紹建立自己的 CocoaPods 流程，而我當初是看了 David 的教學文所跑的流程。
首先，先建立一個新的 Pod
pod lib create YourPodName 接著依照自己的 Pod 內容回答問題，便會生成一個新的專案出來。
再來將 Code.Swift 丟到 Pods/Development Pods/YourPodName，也就是它預設 ReplaceMe.Swift 的那個地方。
最後 README.md 和 YourPodName.podspec 寫一寫就完成了 Pod 的準備。
而預設的 REAMME.md 裡頭，有一個 CI Status，你可以移除或者到 Travis.CI 建構；
從 Travis.CI 那邊可以得知如何建構一個 .travis.yml。
都準備好之後，在 GitHub 上開一個 repository 來放置，記得要放上 tag 標記目前的版本。
pod spec lint YourPodName.podspec 最後就送出去就好了！
pod trunk push YourPodName.podspec 如果你沒有註冊過的話，得先註冊一下：
pod trunk register email@domain.com &#39;Your Name&#39; 而如果你有在 .podspec 裡頭填寫你的 Twitter 的話，就會收到 CocoaPods 貼的文！
如果你搜尋不到你的 Pod 的話，可以清除目前的 cache 就可以順利找到了！</description>
    </item>
    
    <item>
      <title>UUID with version 3, 5 and name spaces</title>
      <link>https://example.com/p/uuid-with-version-3-5-and-name-spaces/</link>
      <pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/uuid-with-version-3-5-and-name-spaces/</guid>
      <description>在 Swift 裏頭，預設的 UUID 只能從 UUID() 來產生，或者是從另一個 UUID 來產生， 這邊來記錄一下如何從 String 來產生 UUID。 首先，先在 Bridge-Header.h 裡頭加入
#import &amp;lt;CommonCrypto/CommonCrypto.h&amp;gt; 再來寫個 UUID 的 extension：
extension UUID { enum UUIDVersion: Int { case v3 = 3 case v5 = 5 } enum UUIDv5NameSpace: String { case dns = &amp;#34;6ba7b810-9dad-11d1-80b4-00c04fd430c8&amp;#34; case url = &amp;#34;6ba7b811-9dad-11d1-80b4-00c04fd430c8&amp;#34; case oid = &amp;#34;6ba7b812-9dad-11d1-80b4-00c04fd430c8&amp;#34; case x500 = &amp;#34;6ba7b814-9dad-11d1-80b4-00c04fd430c8&amp;#34; } init(version: UUIDVersion, name: String, nameSpace: UUIDv5NameSpace) { // Get UUID bytes from name space: let spaceUID = UUID(uuidString: nameSpace.</description>
    </item>
    
    <item>
      <title>Socket.IO</title>
      <link>https://example.com/p/socket.io/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/socket.io/</guid>
      <description>這篇文章會介紹有關於 Socket.IO 在 server 端以及 iOS 端的一些實作分享。
Server 首先我們可以先從 Socket.IO 的 Get started 開始，它是以 Node.JS 所編寫的，所以先在資料夾位置執行
npm init 邊可以取得基本的一些檔案和 package.json。 接著安裝 Socket.IO 所需要的 express
npm install --save express@4.15.2 然後新建一個 index.js 的檔案，貼上
var app = require(&amp;#39;express&amp;#39;)(); var http = require(&amp;#39;http&amp;#39;).Server(app); app.get(&amp;#39;/&amp;#39;, function(req, res){ res.send(&amp;#39;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&amp;#39;); }); http.listen(3000, function(){ console.log(&amp;#39;listening on *:3000&amp;#39;); }); 這樣待會執行 node index.js 的時候便可以從 http://localhost:3000 來連上這個 server。
確認 server 目前是可以連上後，便開始安裝 Socket.IO 到其中
npm install --save socket.io 並在 index.js 裏頭加上 Socket.</description>
    </item>
    
    <item>
      <title>StatusBarStyle</title>
      <link>https://example.com/p/statusbarstyle/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/statusbarstyle/</guid>
      <description>最近改寫了 StatusBarStyle 的控制方式，從 iOS 9 之前是使用
UIApplication.shared.statusBarStyle = .default 並在 info.plist 的 View controller-based status bar appearance 欄位設為 NO。 而後來則改為覆寫 preferredStatusBarStyle 的方式，就不用在 viewWillAppear / viewWillDisappear 的時候手動控制 StatusBarStyle。 首先先確認 info.plist 之中 View controller-based status bar appearance 是為 YSE， 代表我們是透過 View controller-based 的方式來更改 status bar style。
override var preferredStatusBarStyle: UIStatusBarStyle { return .default } 而配合 UINavigationController 的使用，可以以 Subclass 或是 Extension 的方式來實作， 這就得看專案需求了。
Subclass 在 BaseNavigationController 裏頭，利用 childForStatusBarStyle 回傳要呼叫哪個 UIViewController 的 preferredStatusBarStyle
override var childForStatusBarStyle: UIViewController?</description>
    </item>
    
    <item>
      <title>Xcode beta with CocoaPods</title>
      <link>https://example.com/p/xcode-beta-with-cocoapods/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/xcode-beta-with-cocoapods/</guid>
      <description>Xcode 10 beta 的 Swift 版本為 4.2，而若你目前所使用的 Pods 多數為 Swift 4 的話，該怎麼辦呢？
你可以在 Podfile 裏頭加上全域的參數來規範所有 Pods 的 Swift version：
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&amp;#39;SWIFT_VERSION&amp;#39;] = &amp;#39;4&amp;#39; end end end 如此一番便可以輕鬆地在 Pods 還沒全面支援 Swift 4.2 時就可以使用 Xcode 10 Beta 開發👏</description>
    </item>
    
    <item>
      <title>CompactMap vs flatMap</title>
      <link>https://example.com/p/compactmap-vs-flatmap/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/compactmap-vs-flatmap/</guid>
      <description>直接從 code 來看兩者之間和 map 的差異
CompactMap let scores = [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;four&amp;#34;, &amp;#34;5&amp;#34;] let mapped: [Int?] = scores.map { str in Int(str) } // [1, 2, 3, nil, 5]  let compactMapped: [Int] = scores.compactMap { str in Int(str) } // [1, 2, 3, 5] flatMap let users = [User(name: &amp;#34;Archie&amp;#34;, scores: [1, 2, 4]), User(name: &amp;#34;ArchieChang&amp;#34;, scores: [3,2,5])] let mapped = users.map { $0.scores } // [[1, 2, 4], [3, 2, 5]] let flatMapped = users.</description>
    </item>
    
    <item>
      <title>UserDefaults with Structure</title>
      <link>https://example.com/p/userdefaults-with-structure/</link>
      <pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/userdefaults-with-structure/</guid>
      <description>有時候我們會將一些用戶資訊存在 UserDefaults 裡頭，是個方便且直覺的存取方式。
而 UserDefaults 並非是所有型別都可以接受，如你自己建構的 struct 或 class，
就需要先轉成 Data 的格式來存取。
這邊就來介紹如何存取 User 這個 struct：
struct User { var ID: String var name: String var email: String? } 這是一個簡單的 User structure，若要轉成 Data 的話，得先將 User 宣告成 Codable，
這樣就可以透過 PropertyListEncoder 和 PropertyListDecoder 來處理 User 和 Data 之間的 encode decode。
而最近喜歡使用 extension 的方式來處理 UserDefaults：
extension UserDefaults { var user: User? { get { guard let data = data(forKey: #function) else { return nil } return try?</description>
    </item>
    
    <item>
      <title>Git LFS ( Large File Storage )</title>
      <link>https://example.com/p/git-lfs-large-file-storage/</link>
      <pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/git-lfs-large-file-storage/</guid>
      <description>今天在更新 Blay 的 Pods 時，發現 Realm 的某個檔案（60.04 MB）超出了 GitHub 的上限（50.00 MB），所以無法順利地將檔案推上去 GitHub，而 Git 也自行 untracked 那個檔案，所以在 git status 上便失去了蹤影。
至於為什麼會將 Pods 的檔案全推到 GitHub 上呢？
而在 git push 的時候，有顯示解決的方法，便是今天的主題：
Git LFS 首先我們透過 brew 來安裝 git lfs
brew install git-lfs 接著繼續在 git 裡頭安裝
git lfs install 再來我們就來定義哪些檔案需要被 lfs track，像我這邊是這樣：
git lfs track &#39;Pods/Realm/core/librealmcore-ios.a&#39; 然後可以透過指令來確認是否有被加入到 track 的名單
git lfs track git status 現在就可以從 git status 之中再次看到剛剛沒推成功的檔案被 track 了！
git lfs track 的內容會被記錄到 .gitattributes 裡頭，所以也一併推上 GitHub 即可完成！ git push 這樣便可以在 GitHub 上處理單個檔案超過 50.</description>
    </item>
    
    <item>
      <title>Fastlane pilot issue</title>
      <link>https://example.com/p/fastlane-pilot-issue/</link>
      <pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/fastlane-pilot-issue/</guid>
      <description>這是和防火牆有關的 issue
在 fastlane pilot 的 docs 有註記 Firewall Issues
可以透過
ENV[&amp;quot;DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS&amp;quot;] = &amp;quot;-t DAV&amp;quot; 來避免上傳的問題！</description>
    </item>
    
    <item>
      <title>DeviceSupport</title>
      <link>https://example.com/p/devicesupport/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/devicesupport/</guid>
      <description>每當 iOS Beta 更新時，原先的 Xcode 便會無法支援，需要透過從 Xcode Beta 的 DeviceSupport 複製新的版本到正式版之中才能使用； 反正都會做這件事，不如就將 Xcode Beta 裡頭的 DeviceSupport 上傳到 GitHub 上提供給 iOS 有更新，但還沒下載新的 Xcode Beta 的人使用吧！ 傳送門點我</description>
    </item>
    
    <item>
      <title>ignore Pods warning</title>
      <link>https://example.com/p/ignore-pods-warning/</link>
      <pubDate>Tue, 12 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/ignore-pods-warning/</guid>
      <description>在使用 CocoaPods 的時候難免會碰上 warning，原因不外乎就是使用的套件本身在 build 的時候所產生的警告，但不建議直接 unlock Pods 去修改，請以那專案修改，並在處理完後發送 Pull Request 造福大眾。 不過現階段來說，我們可以做的事情是忽略 Pods 的 Warning， 只要在 Podfile 裡頭加上
inhibit_all_warnings! 即可在目前的專案中忽略 Pods 相關的 warning。</description>
    </item>
    
    <item>
      <title>Pods 到底需不需要放在 .gitignore？</title>
      <link>https://example.com/p/pods-%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%94%BE%E5%9C%A8-.gitignore/</link>
      <pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/pods-%E5%88%B0%E5%BA%95%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E6%94%BE%E5%9C%A8-.gitignore/</guid>
      <description>若有使用 GitHub 所預設的 Swift .gitignore，你會發現在 CocoaPods 的部分寫著
# CocoaPods # # We recommend against adding the Pods directory to your .gitignore. However # you should judge for yourself, the pros and cons are mentioned at: # https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control # # Pods/ 用意如同字面上的意思，GitHub 所提供的預設會建議你上傳 Pods 的內容到 git server 上，
而我個人也認同這種做法，目前所想的原因如下：
 可以完整地打包套件當前狀態到 git 上，以避免套件有異動 若你們有直接修改 Pods 裡頭的 Source code 的話，更加得上傳（不過完全不建議這麼做） git clone 下來之後可以不用再 pod install 一次  不過也是有些壞處，如套件越多時，造成 git 上的專案肥大等。
但是像是 Carthage 的話，就會建議加入到 .</description>
    </item>
    
    <item>
      <title>upgrade git</title>
      <link>https://example.com/p/upgrade-git/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/upgrade-git/</guid>
      <description>前言 git 最近被發現有重大的漏洞，以我們能做的事情就是更新自己的 git！
在 macOS 上更新 在 macOS 上，預設的 git 為 git version 2.15.1 (Apple Git-101)， 所以我們需要先透過 brew 來安裝 git。 首先，我們先來更新 brew，這點和 CocoaPods 類似，需要更新本機端的項目； 順道升級 brew 目前裡頭的項目。
brew update &amp;amp;&amp;amp; brew upgrade 接著就透過 brew 來安裝 git
brew install git 最後再將 Symbolic link 處理一下就好了！
brew link --force git 現在我們確認一下 git 是否已經為新版本（git version 2.17.1）！
git --version </description>
    </item>
    
    <item>
      <title>HEROKU</title>
      <link>https://example.com/p/heroku/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/heroku/</guid>
      <description>前言 這幾個月透過家裡頭的桌機來定時跑爬蟲以及更新 Firebase 資料庫，不過電費也是一筆固定支出，所以趁今天想到這件事，便來搬移到免費的 HEROKU 來做這些事。
HEROKU 是一個有提供免費伺服器方案的平台，支援的語言算多，而我的爬蟲是以 Python 3.6 作為開發語言的，故選擇它來玩玩。 在免費的方案之中有一些限制，如 24 小時內得休息 6 小時之類的； 不過在這邊，我需要的只是一個可以執行 Cron Job 的地方，所以不需要升級主機的部分。 目前我的 HEROKU 裡頭包含著三個動作：
 每天台灣時間 00:00 時，到星座網爬蟲並記錄當日運勢到 Firebase 每天台灣時間 09:00 時，到 PTT CodeJob 以及 Soft_Job 版搜尋 iOS 相關的文章，並 mail 到我的信箱 每天台灣時間 12:00 時，爬 PTT 一些熱門看板的文章並發佈到機器人部落格以及機器人推特之中 我分成三個 .py 檔案，下方會說明我的作法。  簡單的建構步驟 首先，先到 HEROKU 的 dashboard 建立一個新的 App，接著照著它的敘述完成 Git 的建置。 我在資料夾當中，放入了下列的檔案：
 PTT.py – 12:00 該做的事 iOS.py – 09:00 該做的事 Astro.py – 00:00 該做的事 requirements.</description>
    </item>
    
    <item>
      <title>Commitizen</title>
      <link>https://example.com/p/commitizen/</link>
      <pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/commitizen/</guid>
      <description>閒聊一下 最近處於求職的階段，評估一份職缺的觀點也和過往不同； 以這篇文章來說，Git Commit Style 便是其中一點，詢問對方是否有固定的 commit 格式， 就可以大致上瞭解團隊的風格是哪種。 若還沒有個規範，或是想要參考的，可以繼續閱讀下去。
Git Commit 是以 AngularJS 的格式，區分成
&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;body&amp;gt; &amp;lt;BLANK LINE&amp;gt; &amp;lt;footer&amp;gt; 其中 type、scope、subject、body、footer 等，有一定的規範， 詳細的內容可以在 angular.js/DEVELOPERS.md 看到。 這篇文章主要要介紹的是一個可以讓 commit 符合上述規範的工具 – Commitizen。
Commitizen Commitizen 是以 Node.js 所開發出的一套工具，使用者可以透過它來處理 commit 的風格一致性。
安裝 我們可以透過 npm 的方式來取得
npm install -g commitizen 並且安裝 cz-conventional-changelog
npm install -g cz-conventional-changelog 在電腦中安裝完上述兩者之後，先切換到你所開發的 iOS 專案資料夾底下， 由於 Commitizen 是以 Node.js 開發，你需要在 iOS 專案裡頭建構一些 npm 所需要的環境， 故記得補上 npm 初始化以及使用 convertional-changelog</description>
    </item>
    
    <item>
      <title>iOS Taiwan jobs</title>
      <link>https://example.com/p/ios-taiwan-jobs/</link>
      <pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/ios-taiwan-jobs/</guid>
      <description>iOS Taiwan jobs 緣起 最近剛把手上的專案都告一個段落，便開始尋找工作上的合作機會。 恰巧看到 f2etw/jobs，透過 GitHub Issues 的方式提供工作資訊， 感覺挺好的，且是個大家都可以共同編輯的地方，於是便有了建立一個 iOS 版本的念頭。
和 f2etw/jobs 差異性 issue title iOSTaiwan/jobs 僅提供 iOS 的工作機會，且技術較為單純（Objective-C、Swift）， 所以便選擇在 issue title 上僅提供公司名稱而已； 職稱以及使用的語言則使用 label 來作為區分依據，如 Intern、Junior、Senior、Swift 等。
issue template 我先是參考了 f2etw/jobs 的範本，並加入部分 PTT Soft_Job 版上的徵才格式，如
 員工是否需自備工具? (是/否) 公司地址(填寫詳細至號)  後記 並在 README 之中，附上一些求職的網站，如 Yourator、indeed 等； 裡頭也都先下好關鍵字，點擊連結可以直接看搜尋結果。 希望可以透過這個專案讓台灣的 iOS 工程師在求職路上有個幫助！
之後再陸續整合一些資源到 Archie.tw 以及 iOSTaiwan，仿效 f2etw 的模式， 有興趣的朋友歡迎多加利用👏</description>
    </item>
    
    <item>
      <title>Word deletion shortcut in iTerm</title>
      <link>https://example.com/p/word-deletion-shortcut-in-iterm/</link>
      <pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/word-deletion-shortcut-in-iterm/</guid>
      <description>在使用 iTerm 的時候，想要一次刪除一個字的話， 可以在 Preferences ➡️ Keys 新增一組 Keyboard Shortcut， Action 選擇 Send Hex Code，並填上 0x17 即可！
 iTerm2</description>
    </item>
    
    <item>
      <title>ProvisionedDevices</title>
      <link>https://example.com/p/provisioneddevices/</link>
      <pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/provisioneddevices/</guid>
      <description>前言 這篇文章的內容會是記錄如何確認目前的 Provisioning Profile 擁有哪些測試裝置， 以便在使用 adhoc 打包時，確保裝置可以執行。
Provisioning Profile Path ~/Library/MobileDevice/Provisioning Profiles/ 在 terminal 下執行
security cms -D -I /path/to/MyProfile.mobileprovision 便可以看到相關的資訊，如下圖：  ProvisionedDevices</description>
    </item>
    
    <item>
      <title>Python – SMTP</title>
      <link>https://example.com/p/python-smtp/</link>
      <pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/python-smtp/</guid>
      <description>前情提要 痞客邦最近「新增文章」API，不斷地出現未知的伺服器錯誤，而且從回應的時間來猜測的話， 感覺像是他們自己本身內部的錯誤導致 Time out 之類的。 礙於目前還無法在短時間內處理好一台伺服器建構多個 WordPress， 所以只好先將內容發佈到 Blogger 來解決當前的問題。 而我們只需要使用到發文的功能，所以就可以簡單利用電子郵件來發文；
 Blogger 設定的「以電子郵件傳送」 使用電子郵件張貼填入電子信箱，並開啟「立即發佈電子郵件」 儲存設定  這樣只要寄信給設定的地址的話，Blogger 便會自動發文。
SMTP 首先在 Python 當中，我們可以使用 smtplib 來發送信件， 下列使用 gmail 為例：
import smtplib smtpserver = smtplib.SMTP_SSL(&amp;quot;smtp.gmail.com&amp;quot;,465) smtpserver.ehlo() smtpserver.login(username, password) 若你直接執行的話，可能會收到登入失敗的訊息； 由於 Google 在安全性設定上，會阻擋安全性較低的應用程式， 所以若要使用的話，則需要開啟相關設定：  登入與安全性   啟用  這樣的話，就可以順利地登入 gmail。 再來準備信件的內容並寄出：
from email.mime.text import MIMEText from email.header import Header from_address = &amp;#39;Archie.Chang.iOS@gmail.com&amp;#39; to_address = [&amp;#39;Archie.Chang.iOS@gmail.com&amp;#39;] message = MIMEText(html_body, &amp;#39;html&amp;#39;, &amp;#39;utf-8&amp;#39;) message[&amp;#39;From&amp;#39;] = from_address message[&amp;#39;To&amp;#39;] = to_address[0] message[&amp;#39;Subject&amp;#39;] = subject smtpserver.</description>
    </item>
    
    <item>
      <title>Firebase Cloud Functions with Database and Messaging</title>
      <link>https://example.com/p/firebase-cloud-functions-with-database-and-messaging/</link>
      <pubDate>Thu, 18 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/firebase-cloud-functions-with-database-and-messaging/</guid>
      <description>Cloud Functions Firebase 一直以來便是以 serverless 為主要的方向， 而 Functions 則是一個十分有趣的功能； 它可以自動地隨著事件的回應，如資料庫的異動或是收到 HTTP 的 requests 時，執行程式碼。 其中一個重點是，我們也不需要去管理或是 scale 伺服器。
Triggers  Cloud Firestore Triggers Realtime Database Triggers Firebase Authentication Triggers Google Analytics for Firebase Triggers Crashlytics Triggers Cloud Storage Triggers Cloud Pub/Sub Triggers HTTP Triggers  範例 需求 Realtime Database 底下的資料有異動的話，進行推播
直接上 Code const functions = require(&amp;#39;firebase-functions&amp;#39;); const admin = require(&amp;#39;firebase-admin&amp;#39;); admin.initializeApp(functions.config().firebase); exports.updateTodayNews = functions.database.ref(&amp;#39;/today/{newsCategory}/updatedTime&amp;#39;).onWrite(event =&amp;gt; { const newsCategory = event.params.newsCategory; return admin.</description>
    </item>
    
    <item>
      <title>Selenium</title>
      <link>https://example.com/p/selenium/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/selenium/</guid>
      <description>Selenium 需要在 Python 上操作瀏覽器的話，我會選擇使用 Selenium； 以爬蟲來說，和 requests 不同的地方在於， 像是在讀取網頁時，使用 Selenium 開啟瀏覽器的話可以幫我們處理掉渲染的問題。 這篇主要會以 Selenium 的方式來取得痞客邦的 Access Token。
先搞懂痞客邦的流程 首先，我們先到痞客邦的開發者網頁  PIXNET  或是可以直接到 API Explorer 的畫面  API Explorer  接下來會需要進行登入的動作  Login  登入成功後，便是授權給 API Explorer 權限來取得 Access token  Granted  最後可以在 API Explorer 的畫面上看到 Access Token。  AccessToken 
程式方面 我們會使用到 Selenium 的這些元件
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import Select from selenium.common.exceptions import NoSuchElementException from selenium.</description>
    </item>
    
    <item>
      <title>Twitter Follow all users script</title>
      <link>https://example.com/p/twitter-follow-all-users-script/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/twitter-follow-all-users-script/</guid>
      <description>追隨所有 Twitter 用戶 之前在弄一個自動發文的機器人，便想要在 Twitter 上同步發送； 而苦無沒有人追隨的情況下，決定先來追隨別人， 看看對方是否會反追隨回來（？ 以結果來看，有一些些功用，互相追隨的機率大概 5 % 左右。  PTT 爆報機器人  儘管多數可能也是機器人加機器人好友，不過至少稍稍提升了痞客邦的流量。
Javascript var FOLLOW_PAUSE = 1250; var FOLLOW_RAND = 250; var PAGE_WAIT = 2000; __cnt__ = 0; var f; f = function() { var eles; var __lcnt__ = 0; eles = jQuery(&amp;#39;.Grid-cell .not-following .follow-text&amp;#39;).each(function(i, ele) { ele = jQuery(ele); if (ele.css(&amp;#39;display&amp;#39;) != &amp;#39;block&amp;#39;) { console.trace(&amp;#39;Already following: &amp;#39; + i); return; } setTimeout(function() { console.trace(&amp;#34;Following &amp;#34; + i + &amp;#34; of &amp;#34; + eles.</description>
    </item>
    
    <item>
      <title>Crontab</title>
      <link>https://example.com/p/crontab/</link>
      <pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/crontab/</guid>
      <description>Crontab Crontab 在 Ubuntu 裏頭是預載的，其功能是可以根據時間參數來執行工作排程； 它的格式如下：
* * * * * command to be executed 依序分別是 分鐘[0-59]、小時[0-23]、日期[1-31]、月份[1-12]、星期[0-6]、command 其中 星期 0 = 天的意思。
符號  「*」：不設限 「,」：分隔時段。例如：30 10,20 * * * command，代表早上十點半和下午八點半執行。 「-」：一段時間範圍。例如：15 9-12 * * * command，代表從九點到十二點的每個 15 分都執行一次。 「/n」：表示每個 n 單位間隔。例如：*/5 * * * * command，代表每隔 5 分鐘執行一次。  * * * * *：每隔一分鐘執行一次。 你也可以使用 @ 來取代五個參數：
 @reboot：僅在開機的時候執行一次。 @yearly：一年執行一次，和0 0 1 1 * command效果一樣。 @annually：（和@yearly一樣） @monthly：一個月執行一次，和0 0 1 * * command效果一樣。 @weekly：一個星期執行一次，和0 0 * * 0 command效果一樣。 @daily：每天執行，和0 0 * * * command效果一樣。 @midnight：（和@daily一樣） @hourly ：每小時執行，和0 * * * * command效果一樣。  輸出 另外，需要設立 command 輸出的地點或方式； 如使用 Postfix 或是直接在 command 後方加上 &amp;raquo; /file_path，</description>
    </item>
    
    <item>
      <title>Facebook 隱私權條款問題</title>
      <link>https://example.com/p/facebook-%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE%E5%95%8F%E9%A1%8C/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/facebook-%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%A2%9D%E6%AC%BE%E5%95%8F%E9%A1%8C/</guid>
      <description>由於之前上架的 App 有使用到 Facebook 的登入功能， 於是這幾天一直收到這類的信件： Demo 但是由於本身對這方面可以說是完全沒有涉略， 所以便找找有沒有什麼辦法解決。
Free Privacy Policy
於是找到了這個，回答五種題型便可以得到它們產生的條款， 再找個地方貼上補連結到 Facebook 即可！</description>
    </item>
    
    <item>
      <title>CocoaPods</title>
      <link>https://example.com/p/cocoapods/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/cocoapods/</guid>
      <description>上一篇介紹 Carthage，這篇寫一下 CocoaPods。 其實我個人是先使用 CocoaPods，後來才部分改用 Carthage 作為主要的管理方式； 而 CocoaPods 的安裝方式也很簡單，可以透過 gem 來安裝：
安裝 sudo gem install cocoapods 不同於 Carthage 的 Cartfile，CocoaPods 的是使用 Podfile， 格式有些不同，不過都可以在資料夾下使用 Terminal 輸入初始化的指令：
pod init 系統就會自行建立一個 Podfile，並用 pod search 的指令來找找你要什麼東西。 弄完 Podfile 之後，就可以執行安裝進專案：
pod install 並打開它幫你建立的 .xcworkspace 就好了。
一些分享  可安裝的版本和 GitHub 上寫的不同？ CocoaPods 會建立一個 local 的所有 repo 資訊，若找不到的時候，可以先試著更新它：  pod repo update  Carthage 和 CocoaPods 是可以混用的  </description>
    </item>
    
    <item>
      <title>Carthage</title>
      <link>https://example.com/p/carthage/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/carthage/</guid>
      <description>Carthage 是一個套件管理的開源軟體，可以使用 Homebrew 安裝：
brew install carthage 和 CocoaPods 的差異在於它並不會將第三方的 Framework 直接加入專案， 而是獨立在外，並在 build 的時候直接將 framework 複製進去到 App 內； CocoaPods 的話則會在每次 build 的時候同時 build 你所匯入的 framework， 而隨著專案使用到的套件內容越多，則會花越多時間。
去中心化 這個詞最近隨著區塊鏈的爆紅，也常常可以看見。 不過在這邊的情境是，CocoaPods 是由它那邊搜集很多個 repo，提供給我們來安裝； 所以若 CocoaPods 的 repo 資料沒更新，或是作者只放在 GitHub 上，沒有提交到 CocoaPods 的話， 則無法使用。 而 Carthage 則沒有這方面的問題，可以自行將 GitHub 上的專案加入到 Cartfile
github &amp;quot;ReactiveX/RxSwift&amp;quot; 不過這也是比較麻煩的地方，我們就沒有辦法像 CocoaPods 一樣直接在 Terminal 下 pods search RxSwift 來取得資訊。
個人的使用方式 由於我自行在開發，同時會有很多個專案用到相同的 framework（e.g RxSwift、Siren）， 原本若是使用 CocoaPods 的話，則會在很多資料夾內都有一樣的東西； 而 Carthage 的話，則是將 FRAMEWORK_SEARCH_PATHS 都指定到同一個資料夾即可， 並在 Build phase 加上 Carthage 的 Run script。 而我大多數只會開發 iOS 的 App，Carthage update 的時候則可以只更新 iOS 的部分：</description>
    </item>
    
    <item>
      <title>FireabseDatabase - Read</title>
      <link>https://example.com/p/fireabsedatabase-read/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/fireabsedatabase-read/</guid>
      <description>之前有寫過 FirebaseDatabase REST API的文章， 而這篇則會是在 iOS 上的使用。
安裝套件 由於 Google 認為 Carthage 的方式不符合他們的使用模式， 畢竟 Firebase 的 framework 並非是開源的， 所以只有提供 CocoaPods 的安裝方式或是直接下載檔案； 而我這邊就以 CocoaPods 來安裝 Firebase 相關的套件，其他則用 Carthage 來管理。
設定 我們在 Firebase console 那先建立好專案並匯入 GoogleService-Info.plist， 如果你有多個 Target 要使用的話，建議放在不同的資料夾，並且設定好 Target Membership。 並且要注意 Firebase console 內的 Database rules， 若沒有做 auth 相關內容的話，記得要調整； 如我開放給 App 讀取但不可寫入的話：
{ &amp;quot;rules&amp;quot;: { &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;, &amp;quot;.read&amp;quot;: true } } 接著在 AppDelegate.swift 中加入
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?</description>
    </item>
    
    <item>
      <title>MKGeodesicPolyline</title>
      <link>https://example.com/p/mkgeodesicpolyline/</link>
      <pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/mkgeodesicpolyline/</guid>
      <description>先來看看 MKGeodesicPolyline 在 Apple Developer Documentation 上的介紹： A line-based shape that follows the contours of the Earth to create the shortest path between the specified points.
繪製 Polyline 首先我們在建置 MKGeodesicPolyline 的時候， 給予它一個 [CLLocationCoordinate2D]，並宣告要繪製幾個點； 接著讓 MKMapView 新增進去。
let geodesicPolyline = MKGeodesicPolyline.init(coordinates: [start, end], count: 2) mapView.add(geodesicPolyline) 再來我們需要透過 MKMapViewDelegate 的 function 來定義 MKGeodesicPolyline 的 UI：
func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&amp;gt; MKOverlayRenderer { guard let polyline = overlay as? MKPolyline else { return MKOverlayRenderer(overlay: overlay) } let renderer = MKPolylineRenderer.</description>
    </item>
    
    <item>
      <title>Siren – 通知使用者更新</title>
      <link>https://example.com/p/siren-%E9%80%9A%E7%9F%A5%E4%BD%BF%E7%94%A8%E8%80%85%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/siren-%E9%80%9A%E7%9F%A5%E4%BD%BF%E7%94%A8%E8%80%85%E6%9B%B4%E6%96%B0/</guid>
      <description>我們時常可以在 App 之中看到，「目前有新版本可以提供下載」等相關的訊息； 而實作通知使用者更新的方法很多，這篇則是介紹一個開源的 Framework：
Siren Siren 的運作邏輯是，你可以透過版號來決定跳出什麼通知來提醒使用者， 並且提供多語系的訊息內容。 它會透過 Bundle Identifier 去 App Store 上尋找資訊， 再來比對版號執行後續動作。
版號的定義 1.0.123.5678  1：major 0：minor 123：patch 5678：revision  一般我個人的習慣是： major 會是在商業模式改變或是重大功能發布時，才會動到的； 而 minor 則是有必要的更新，像是嚴重的 bug 或是無法向下相容的異動。 patch 是更新一些 issue 或是修正 bug； revision 則讓它跟著 commit 的數量。
Siren 的設定 舉個例子，在 major、minor 有提升時； 像是從 1.0.0 -&amp;gt; 2.0.0 或是 1.0.0 -&amp;gt; 1.1.0， 我會希望舊的使用者一定要更新 App 才能使用， 則會設為強制更新（.force）。 而 patch 則讓使用則決定要不要更新，或是可以跳過此次更新。
Siren.shared.majorUpdateAlertType = .force Siren.shared.minorUpdateAlertType = .force Siren.shared.patchUpdateAlertType = .</description>
    </item>
    
    <item>
      <title>UIActivityViewController</title>
      <link>https://example.com/p/uiactivityviewcontroller/</link>
      <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/uiactivityviewcontroller/</guid>
      <description>這些話寫在前面⋯⋯ 最近在開發的產品需要加入「分享」的功能， 希望將一些資訊及圖片分享到其他 App 或平台上； 這篇文章會先點出需求，再逐一闡述開發的過程。
需求  Facebook 分享 hash tag 及圖片 其餘分享文字及圖片和網址  實作 我們利用 UIActivityViewController 來呈現分享的選單，並將分享的內容塞入 activityItems: [Any] 之中； 而 applicationActivities 則設為 nil，並沒有要客製 activity。 若沒有需要依照不同類別做出不同的判斷，我們可以將內容放置進去； 像是 URL、String、UIImage等等。 而幾個特點要注意一下：
Facebook：  String 只支援一個 hash tag（像是：“#Archie”），若超過或其他一般文字則不會顯示 有網址的話，就會顯示連結；意思是圖片和連結無法同時出現，會優先顯示連結  iMessage 若 String 裡頭的時間格式為 dd/MM/yyyy HH:mm 則可以點擊，並加入行事曆 圖片會以另一則訊息傳送 網址會以縮圖顯示（就如一般訊息收到的邏輯）
依照類別提供不同內容 首先，我們可以先看 UIActivityType：
extension UIActivityType { @available(iOS 6.0, *) public static let postToFacebook: UIActivityType @available(iOS 6.0, *) public static let postToTwitter: UIActivityType @available(iOS 6.</description>
    </item>
    
    <item>
      <title>3D Touch</title>
      <link>https://example.com/p/3d-touch/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/3d-touch/</guid>
      <description>這些寫在前面⋯⋯ 最近剛從 iPhone 6 Plus 晉升到 iPhone X，其中一項硬體差異便是「3D Touch」； 而這也讓我花了一些時間，來加入 3D Touch 的相關功能開發。 這篇文章前半部會寫 3D Touch 在主畫面上的一些差異， 後半部才會補上 Swift 的相關寫法。
iOS 版本：11.1.1（15B150） 首先，先將 App 分成有 Today extension 以及沒有 Today extension 的這兩種：
郵件 – 有 Today extension
鬧鐘 – 沒有 Today extension
從這兩張圖的比較下，我們可以得知在 iOS 11.1.1 之中， 若有 Today extension 的 App，在 3D Touch 的快捷鍵之中， 會顯示 Today extension，而反之則僅會露出原本的 App icon。 另一點是，快捷鍵的順序是依 index 越小則越靠近 App icon； 所以使用者將 App 放置在畫面上半部或下半部會影響由上到下的順序。
鬧鐘 – 放置畫面下半部
所以便不必太在意快捷鍵的排序問題，包含 Today extension 順序也是。</description>
    </item>
    
    <item>
      <title>失業給付 &#43; 提早就業獎金</title>
      <link>https://example.com/p/%E5%A4%B1%E6%A5%AD%E7%B5%A6%E4%BB%98-%E6%8F%90%E6%97%A9%E5%B0%B1%E6%A5%AD%E7%8D%8E%E9%87%91/</link>
      <pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%A4%B1%E6%A5%AD%E7%B5%A6%E4%BB%98-%E6%8F%90%E6%97%A9%E5%B0%B1%E6%A5%AD%E7%8D%8E%E9%87%91/</guid>
      <description>這些話寫在前面⋯⋯ 由於和上一間公司的工作方式處不來，而對方決定以資遣的方式來處理， 故便在六月中解鎖了「領取資遣證明」的成就。
知道對方要資遣你時，先確認幾件事  近三年內勞保是否有投保滿一年 對方是否通報勞保局 對方是否會開立資遣證明  至於對方是用什麼條款開立，個人是認為沒什麼差異。
若上述的答案皆為「是」的話，你可以⋯⋯ 申請「失業給付」，而這篇文章會以我申請的流程為主，並以流水帳的方式呈現。
2017/06/14（三） 對方中午開立資遣證明，並在上方註明最後工作日為 2017/06/16（五）， 也就是會支薪到週五的意思； 而上方會寫上這個月將依比例給付多少薪資以及資遣費計算結果。
當天，便電話聯繫板橋就業服務站，詢問相關資訊和預約失業給付申請； 而對方有提供給我幾項重點：
 失業給付申請得在最後工作日的隔一天後，以我的案例是 2017/06/17（六）以後申請 可以透過電話進行預約申請，並建議於預約時間前十分鐘先去填寫書面資料 記得帶預計讓失業給付入帳的銀行簿子影本，或帶正本去影印 攜帶證件及資遣證明正本 新北市的就業服務站失業認定無需當日現場報到，而台北市則需要  2017/06/19（一） 上午便到板橋就業服務站填寫書面資料，並和服務人員進行後續動作； 期間對方和我閒聊一些工作上的事，以及職業選擇之類的， 並提供一些就業的資訊和講座。 流程上會需要在 14 天內，進行兩次以上的「找工作」； 對方會要求要上「台灣就業通」（或是其他政府機關提供的找工作平台）， 去申請面試，並於兩週後和服務人員回報狀況。 回報的內容是一張表，需要填寫完之後送回就業服務站，也就是「第一次失業認定」； 板橋就業服務站可以透過郵寄的方式，將表格回寄，並打電話給當時接洽的人員即可， 而台北市則需要再跑一趟親送。
2017/07/03（一） 打電話向服務人員確認狀況，並告知 14 天內沒有工作（以勞保投保記錄為主）， 請對方將第一次認定的申請書送到勞保局，而後續他們會繼續處理。
2017/07/04（二） 持讀卡機到勞保局網頁，以自然人憑證查詢相關進度和資訊； 這邊建議下載「勞保局行動服務」，並進行「個人查詢」的裝置認證， 認證完後，之後都可以透過此 App 查詢，無需再用讀卡機進行登入。
2017/07/12（三） 核付通過，並會在 3 至 5 個工作天匯款至當初提供的銀行戶頭之內。
2017/07/17（一） 收到第一個月的失業給付，而若還未找到工作，則每個月需要再進行認定； 不過我已經有在工作，故沒有進行後續的失業給付申請認定。
找到工作後，接下來呢⋯⋯ 當時在申請失業給付時，服務人員會告知「提早就業獎金」的申請規則和獎金計算方式： 為尚未領取失業給付金額（以我來說，便是 5 個月的失業給付金額） x 50% 一次性發放。
2017/10/05（四） 使用讀卡機到勞保局網頁線上申請「提早就業獎金」，兩分鐘內點選完後送出。
2017/11/01（三） 核付通過，並會在 3 至 5 個工作天匯款至「提早就業獎金」所申請的銀行戶頭之內。</description>
    </item>
    
    <item>
      <title>重灌 macOS 的工程（下）- Terminal 篇</title>
      <link>https://example.com/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8B-terminal-%E7%AF%87/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8B-terminal-%E7%AF%87/</guid>
      <description>前情提要 重灌 macOS 的工程（上）
開始進入本篇 iTerm2 首先要先處理的，是 Terminal 的部分； 除了 macOS 所內建的 Terminal 之外，我目前嘗試使用 iTerm2， 主要是看上有較多個人化設定的部分。 而我所使用的主題風格是 Dracula，相關的安裝方式裡頭有蠻清楚的介紹。
Homebrew 這套相信大家都不會太陌生，而不清楚的人就在這邊簡單解釋一下， Homebrew 主要是負責 Mac 上的一些套件管理； 就有點像是 Swift package manager、CocoaPods 或是 Carthage。
zsh 在 iterm2 之中安裝完 homebrew 之後， 接著就繼續來安裝 zsh，其主要是用來取代原先內建的 bash， 也是這次重灌後開始嘗試使用的新玩意之一。 而在下載安裝完 zsh 後，會被默認安裝在 /usr/local/bin/zsh（或者出現 /usr/local/bin/zsh-5.4.2）， 我們要將 zsh 替換掉 bash，需要下一行指令 chsh -s /usr/local/bin/zsh-5.4.2 chsh 的意思便是 change shell，也就是將原本使用的 shell 換成指定路徑。 不過由於 macOS 對於 shell 有防範，所以你可能會得到這種錯誤訊息： non-standard shell 遇上這個時，我們就得編輯 /etc/shells，將我們剛剛所安裝的路徑放進， 讓系統明白這是一個可以拿來使用的 shell 路徑。</description>
    </item>
    
    <item>
      <title>UIImage memory issue</title>
      <link>https://example.com/p/uiimage-memory-issue/</link>
      <pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/uiimage-memory-issue/</guid>
      <description>今天要來分享的內容，是有關於 UIImage 的一個記憶體爆炸情況， 而我先闡述一下發現這問題的情境： 專案內有個功能會需要匯入大型圖片做縮放以及拖拉功能， 使用者可以切換大型圖片，而在點擊過多的圖片時，便會造成記憶體爆炸。
原先的做法 在使用者點擊叫出某張圖時，會使用 UIImage(name: ImageName) 來產生 UIImage 物件，並將畫面上的 UIImageView.image 設為它。 看起來蠻合理的，當使用者切換後，我會再生成一個新的 UIImage 物件，並取代前者； 這樣前者就應該會釋放掉記憶體空間了！
但⋯⋯事情並不是這樣發展 在使用者切換幾次後，發現記憶體只有一直往上增長，而未釋放掉； 意思是指雖然我將畫面上的 UIImageView.image 取代掉了， 不過實際上仍然佔據著記憶體空間⋯⋯
為什麼？ 上網查了一下後，發現 UIImage(named: ImageName) 這種生成方式， 會自行將取出來的圖片放置到 cache； 而上述的使用情況就會變成當使用者一切換，便會將另一張大型圖片放置到 cache 而未釋放掉前一張。
改良的做法 Data 在建構的時候，有一種選項是 .uncached， 也就是說，我們可以先將圖片以 Data 的方式打開，再轉回 UIImage， 則就可以避免掉它自動放置到 cache 而記憶體爆掉的情況。
if let url = Bundle.main.url(forResource: ImageName, withExtension: &amp;#34;.png&amp;#34;), let data = try? Data(contentsOf: url, options: Data.ReadingOptions.uncached) { let image = UIImage(data: data) imageView.image = image } 這樣就可以解決 UIImage 的 cache 導致記憶體爆炸的情況。</description>
    </item>
    
    <item>
      <title>雙 NP：中華電信➡️台灣大哥大➡️中華電信</title>
      <link>https://example.com/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1/</link>
      <pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E9%9B%99-np%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1%EF%B8%8F%E5%8F%B0%E7%81%A3%E5%A4%A7%E5%93%A5%E5%A4%A7%EF%B8%8F%E4%B8%AD%E8%8F%AF%E9%9B%BB%E4%BF%A1/</guid>
      <description>首先，先附上地標網通的價目表， 我所要選擇的方案是雙 NP 回中華電信的智慧大玩家 999 方案， 而方案內容是 24 個月，每月月租 999 元，4G 吃到飽，網內60分/網外50分/市話20分。 透過雙 NP 的流程，我可以拿到 11,000 元的攜碼折扣，而算一下每月月租費約為 (999 x 24 – 11,000) / 24 = 540.66667 元
闖關流程 第一步，先確認一下自己的合約狀況： 以我的例子來說， 合約原本內容：
我們可以看到，大多數的合約到期日為 10-03， 但由於第一項合約，其正是去年申請的老客戶優惠方案； 而它的到期日是在 12-23，所以我還是得到中華電話一趟來申請攜出。 於是我便在 10-03 當天的 17：30 左右， 到中華電信的長春服務中心辦理攜出業務。
從中華電信攜出 和櫃檯人員說明我要攜出門號，而她也沒有多問些什麼， 便請我提供資料以及詢問門號轉出費用 240 元， 是要選擇跟著當期帳單還是直接繳清。 選擇直接繳清後，並簽個名，就順利拿到收據離開了； 前後加上等候叫號的時間，約莫十分鐘。
還沒離開中華電信，便收到了相關通知簡訊。
到台灣大哥大辦理門號攜入 接著到附近的台灣大哥大林森北二直營服務中心， 一進去後副店長便詢問我門號，而當我表示要轉入 4 G 1.8 的方案時， 他便直接問我是否要雙 NP，以及原電信是否為中華電信！ 我點了點頭示意，便交出了雙證件和簽了兩處名字， 他告知我通常隔天就可以再到台灣大哥大辦理攜出， 一樣繳納 240 轉出費後便可以去走接下來的流程！ 前後大概花了五分鐘，便簡單完成門號攜入了！
再來就等明天的流程⋯⋯
到台灣大哥大攜出 攜出流程應該和中華電信大同小異，明天預計到羅東台灣大哥大興東店辦理。
最後，到地標網通申請智慧大玩家 999 方案 接著再到羅東的地標網通，出示從台灣大哥大攜出的收據辦理後續等開通。</description>
    </item>
    
    <item>
      <title>重灌 macOS 的工程（上）</title>
      <link>https://example.com/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8A/</link>
      <pubDate>Wed, 27 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E9%87%8D%E7%81%8C-macos-%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%B8%8A/</guid>
      <description>前言 幾天前，Apple 釋出了 High Sierra 的安裝檔， 一時手癢的我，便將自己的 MacBook Pro (Retina, 13-inch, Mid 2014) 來進行更新！ 早上上班前出門開始更新，晚上回到家後卻還卡在剩餘 33 分鐘處⋯⋯ 覺得詭異的我，便強制關機，而再次打開便只能 command + R 開始重灌系統。 但事情往往不會那麼簡單，在重灌系統時，一直遇上卡在剩餘 1 分鐘的進度； 使用 command + L 查看安裝記錄，便發現是一直在安裝檔的驗證失敗⋯⋯ 直到今天早上，在重灌一次，才順利完成 High Sierra 的安裝。
但故事往往都不會那麼順利 不知道為什麼的，我的 Disk password 一直輸入失敗， 但在 command + R 的修復模式之中，那組密碼是可以順利解開 Filevault 的⋯⋯ 進入到重置密碼的頁面後，跟著步驟完成後卻得到發生內部錯誤的訊息⋯⋯ 反覆試了幾次之後，得到兩個結論：
 格式化硬碟再重灌看來是最快的方式 下次絕對不要輕易使用 Filevault  於是乎，花了數個小時後，便得到一台新的 MacBook Pro！
而既然都走到這步田地了，不如就順勢將自己的環境配置逐一記錄下來⋯⋯
觸控板相關 首先，第一步我都會先將觸控板相關的內容弄一弄， 這樣待會做其他事情也都會較快一些：
點一下來選按：這樣就不用真的按下觸控板才會有動作
輔助使用➡️滑鼠與觸控式軌跡板➡️觸控式軌跡板選項⋯：啟用拖移
一般 使用暗色選單列和 Dock：我個人喜歡這配色的 macOS
聲音 在選單列中顯示音量：這樣在切換聲音輸出的時候很方便，從內建揚聲器到藍牙耳機
iCloud 能勾的全勾：單純在 iPhone、iPad、以及其他 Mac 之間切換很方便</description>
    </item>
    
    <item>
      <title>Swift 4 JSON</title>
      <link>https://example.com/p/swift-4-json/</link>
      <pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/swift-4-json/</guid>
      <description>在 Swift 之中，JSON (JavaScript Object Notation) 的型別為 [String: Any]， 也就是一個 Dictionary 的概念，以一組 Key 對應一組 Value。 大多數會碰到 JSON 格式是在做網路溝通時， 使用 JSON 格式並 encode 成 Data 的型態在傳輸資料。
Swift 3 以前 我們從 URLSession.shared.dataTask 的 handler 之中， 會得到 data、response 及 error，其中的 data 會使用下面的方式才轉換成 JSON：
/* Create a Foundation object from JSON data. Set the NSJSONReadingAllowFragments option if the parser should allow top-level objects that are not an NSArray or NSDictionary. Setting the NSJSONReadingMutableContainers option will make the parser generate mutable NSArrays and NSDictionaries.</description>
    </item>
    
    <item>
      <title>Third-party Payment</title>
      <link>https://example.com/p/third-party-payment/</link>
      <pubDate>Thu, 07 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/third-party-payment/</guid>
      <description>Third-party Payment 這篇要來聊聊第三方支付，其主要的內容會介紹幾個台灣所可以使用的第三方支付方案； 而第三方支付主要解決的問題是，替我們向銀行方溝通及串接請款等動作， 讓使用者可以透過第三方支付的服務付款，而我們再和第三方支付的服務商談拆帳方式， 它可以讓我們不必親自去和銀行接洽運作的方式，只需要透過其官方的一些文件或是管理後台， 便能較輕易地處理掉金流這一塊的相關問題。 而這邊會談到下列幾間的一些資訊：
 智付通 綠界 TapPay  智付通 智付寶為智冠科技旗下的金流平台公司，而智付通則是其主要的服務名稱。
會員 我們需要先到智付通的網站之中，創建一組收款帳號：
企業會員的部分，可以透過業務的接洽去談彼此之間的手續費抽成數字， 再來就可以串接其 API 來進行相關的開發動作。
支援的支付方式  超商代收 信用卡 ATM / WebATM Pay2go 電子錢包（他們自己的產品）  費用 智付通的商業模式是抽取交易手續費的模式：
其中，舉個例子： 像是信用卡一次付清 2.80% 的意思是，信用卡支付銀行本身可能是抽取 1.80%， 而智付通要賺的錢，便是 2.80 – 1.80 = 1.00 %。
備註 之前同事在串接 API 時，踩過幾次文件和實際 response 不符的雷⋯⋯
綠界 會員以及收費 綠界的個人會員和商務會員差異性，從圖表上看來只在於收款額度上的不同； 而特約會員（應該是從業務去接洽的）則是可以去談判的「依雙方議定」。
支援的支付方式  超商代收 信用卡 ATM / WebATM Apple Pay Android Pay 全家條碼立即儲  TapPay TapPay 的商業模式則和上述兩者不太相同，前面所提及的廠商， 是在每筆交易之中抽成當作手續費， 而 TapPay 則是以單筆固定金額來收取費用； 原因是在於，在使用 TapPay 時， 我們需要和相關的銀行簽妥相關文件，讓錢直接轉進我們的戶頭內， 也就是說 TapPay 實際上並不會先將錢都收進它那， 而是一個幫忙在銀行和我們之間作溝通的角色。</description>
    </item>
    
    <item>
      <title>Credit Card Number</title>
      <link>https://example.com/p/credit-card-number/</link>
      <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/credit-card-number/</guid>
      <description>最近在串信用卡支付相關的服務，順道筆記信用卡卡號的相關規則。
驗證卡號 信用卡卡號的驗證方式是，最後一碼為驗證碼； 舉個例子來說： MasterCard – 5200 8282 8282 8210 其中最後一碼 0 是由 5200 8282 8282 821 去做一些邏輯運算後得到的結果； 也就是你其實可以前面隨便亂打，最後一碼再從 0 測試到 9 就可以通過基本的卡號驗證。
驗證方式 信用卡的驗證方式，是用 The Luhn Formula，也就是說， 當我們取得一組卡號，驗證碼產生的流程為：
 去掉最後一碼（5 2 0 0 – 8 2 8 2 – 8 2 8 2 – 8 2 1） 把整串倒過來（1 2 8 – 2 8 2 8 – 2 8 2 8 – 0 0 2 5） 排序奇數的數字 x 2（2 2 16 – 2 16 2 16 – 2 16 2 16 – 0 0 2 10） 超過九的數字則 – 9（2 2 7 – 2 7 2 7 – 2 7 2 7 – 0 0 2 1） 將所有數字相加（50） 取尾數（0）  得到驗證碼為 0，則卡號 5200 8282 8282 8210 為正確的卡號格式。</description>
    </item>
    
    <item>
      <title>Status bar style</title>
      <link>https://example.com/p/status-bar-style/</link>
      <pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/status-bar-style/</guid>
      <description>Status bar style 一般在 iOS 裡頭，status bar style 可以被分成兩種
 default lightContent  設定方式 我們可以在 info.plist 做全域的設定，讓整個 app 在執行的時候，都是同樣的 style； 這取決於 View controller-based status bar appearance – YES / NO 若設為 NO，則是整個 app 都會是同樣的 style； 而若設為 YES，就能在個別的 viewController 來做設定。
View controller-base status bar appearance – YES 實作方式是更改 UIViewController 底下的 preferredStatusBarStyle， 而因為它是 { get } 的，所以我們只能透過覆寫的方式來更改：
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } UINavigationController 如果你要更改的 UIViewController 是包在 UINavigationController 裡頭的話， 則需要更改的是 UINavigationController 的 preferredStatusBarStyle， 而非是當前的 UIViewController。</description>
    </item>
    
    <item>
      <title>ViewModel with POP</title>
      <link>https://example.com/p/viewmodel-with-pop/</link>
      <pubDate>Fri, 11 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/viewmodel-with-pop/</guid>
      <description>ViewModel with POP 這邊有兩個名詞需要解釋一下，一個是 ViewModel，另一個則是 POP：
ViewModel 在 iOS 的開發模式中，從你新建一個新專案的時候，它的預設內容是以 MVC 的架構為底； 而在 MVVM 的架構中，會在 View 以及 Model 之間，多夾帶一層 ViewModel 來分工。 在實作 ViewModel 的時候，我是以 structure 的方式才建構 ViewModel， 並在裡頭宣告 init(model: Model) 的方式，來將 Model 轉成 ViewModel。
struct User { var id: String var name: String var age: Int } struct UserViewModel { var title: String var content: String init(user: User) { title = user.name content = &amp;#34;Hi, 我是 \(user.name)，今年 \(user.age)歲！&amp;#34; } } POP POP（Protocol-Oriendted Programing）是以 Protocol 來傳遞的方式； 以 UITableViewCell 來說，我會建立一個：</description>
    </item>
    
    <item>
      <title>iOS UIView shadow</title>
      <link>https://example.com/p/ios-uiview-shadow/</link>
      <pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/ios-uiview-shadow/</guid>
      <description>最近在寫的專案，使用到比較多的陰影效果，就來列列有關陰影效果的一些內容。
CALayer 陰影相關的實作方式，是以 CALayer 底下的這五個變數來控制
 shadowColor: CGColor? shadowPath: CGPath? shadowOffset: CGSize shadowRadius: CGFloat shadowOpacity: Float  shadowColor 預設值為不透明的黑色，我們可以透過這個參數來調整陰影的顏色。
shadowPath 預設值為 null，並支援 animated，可以在這邊調整陰影的路徑， 所以當 UIView 在透過 animated 調整大小時，我們可以一併調整 shadowPath 來跟著做變化。
shadowOffset 預設值為 [0, -3]，來調整陰影的位移。
shadowRadius 預設值為 3，系統本身會進行發散的動作。
shadowOpacity 預設值為 0，也就是完全透明； 所以如果只是要陰影，並沒有需要客製化的話， 只需要修改 shadowOpacity，畫面上就會有 offset = [0, -3], radius = 3 的不透明黑色陰影出現。
cornerRadius 這邊有點需要注意到的是，若要有 shadow 效果的話，下面兩者必須為 false
 layer.masksToBounds clipsToBounds  因為若將 layer 只關閉在 bounds 的話，則無法呈現陰影的效果； 但偏偏若需要圓角效果的話，則必須更改為 true。 而這邊，我的做法是， 先建立一個透明色的 UIView，來做陰影的效果， 再疊加一層 subview 來做圓角的效果， 這樣便可以做出有陰影效果的圓角 UIView 了！</description>
    </item>
    
    <item>
      <title>iOS User Interface Default Value</title>
      <link>https://example.com/p/ios-user-interface-default-value/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/ios-user-interface-default-value/</guid>
      <description>我們在開發 iOS App 的時候，對於 User interface 的開發模式有幾種流派
 Storyboard Storyboard + xib xib Code  而這篇的主題，先撇除純 Code 流的開發方式，來聊聊使用 Storyboard 和 xib 的朋友，會遇到什麼事。
先說說為什麼我使用 User interface（Storyboard, xib） 一方面是因為一開始學習的時候，教學是從拉拉元件，連動按鈕開始， 比起純 Code 的寫法，這樣也讓人比較好上手； 再來便開始弄一些 Auto layout，讓畫面越來越完整。 而其中一點是，方便和設計師做討論， 看著畫面來調整 UI 會比我一直重新 Build 出 App 還快得一些。 但也正是為了讓設計師可以看到畫面，我可能得在一些 UIKit 的元件上先放置好預設的值， 好比說：
儘管這個 UIViewController 在 viewDidLoad 的時候，會再配置一次多語系的文案以及更換些 icon 或者顏色， 但至少在初步上可以看到大概會長什麼樣子。
若不清空預設值呢？ 我們就可能在部分畫面上會看到，原本打在 xib 的 UITextField 上的值（e.g Hinet CHT Auto）， 甚至是可能有些元件的 isHidden 是由程式判斷出需不需要呈現， 而畫面顯示到判斷完畢的中間，會造成畫面上元件閃現的情況。 於是原先我的做法會：
 清空 xib 上的所有預設值 在 viewDidLoad 的狀態，執行清空的動作  前者的做法，會影響到的就是 xib 失去了給設計師觀看的意義， 因為全空的畫面並不符合使用者的情境； 而後者的做法，當元件一多的時候，有時便會有疏忽。</description>
    </item>
    
    <item>
      <title>GraphQL</title>
      <link>https://example.com/p/graphql/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/graphql/</guid>
      <description>GraphQL v.s REST 首先，看到這個標題，要先了解一下什麼是「REST」； 我們在先前的文章中有提到關於 Firebase Database REST API 的內容， 但並沒有在文章內解釋其含義是什麼。
REST REST（Representational State Transfer），是一種架構，而非協定或是標準； 透過 HTTP 協議所提供的動作（POST、GET、PUT、DELETE）來對資源進行 CRUD（Create、Read、Update、Delete）， 並以 URI 的方式來指定資源：
 POST /games：建立遊戲 GET /games：取得遊戲清單 PUT /games/123：修改 id = 123 的遊戲內容 DELETE /games/123：刪除 id = 123 的遊戲 在 iOS 開發的串接 RESTful API 的經驗中，不論是取得的資料，或是回傳回 server 的資料， 大多是以 JSON 的格式在做溝通。 前後端之間可以透過 RESTful 的方式進行明確的溝通，進而開發出相對應的功能。  REST 的缺點 但有時候還是會遇到一些問題
會拿到多餘的欄位 巢狀資源的處理 越來越多支 API 會拿到多餘的欄位
有時候我們為了顯示一個商品，在畫面上需要呈現
 商品名稱 價錢 照片 URL  但可能在 GET /products/1 的時候，會拿到整個商品的資料回來：</description>
    </item>
    
    <item>
      <title>chmod with ssh key</title>
      <link>https://example.com/p/chmod-with-ssh-key/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/chmod-with-ssh-key/</guid>
      <description>chmod 是由 change mode 所組成，其指令功能便是更改檔案或者資料夾底下所有檔案的權限。 而權限位是由 9 個權限位來控制，每 3 位為一組，分別為
 User Group Other  chmod 的八進位語法的數字說明：
 r: read – 4 w: write -2 x: execute – 1 所以，舉個例子： 5 = 可讀可執行（4 + 1） 6 = 可讀可寫（4 + 2） 7 = 可讀可寫可執行（4 + 2 + 1） 那麼，chmod 600 則就代表著 User 可讀可寫，但 Group 和 Other 則無法使用。  chmod ssh key 若我們更改一下 ssh 的 private key，會發生什麼事呢？
如圖片測試結果所示，ssh 的 private key 僅能開放 User 的權限， Group 和 Other 則都不能開放，否則就會無法使用。</description>
    </item>
    
    <item>
      <title>Firebase Database REST API</title>
      <link>https://example.com/p/firebase-database-rest-api/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/firebase-database-rest-api/</guid>
      <description>這篇主要的內容會是簡單地記錄一下 Firebase Database RESTful API， 所提供的相關內容和使用方式。
Firebase Database Firebase database 的儲存資料方式是屬於 NoSQL 的方式， 利用一組 key 配對一組 value 的模式來建構資料庫； 而在 Database 的介面中，我們可以清楚地看到資料是以 JSON 的格式呈現。
在 iOS 開發的過程中，如果要使用 Firebase 的相關內容， 可以使用官方所提供的 Firebase iOS SDK； 或是在使用 Python 開發的時候，我會選擇使用官方推薦的 Pyrebase， 那若你目前的開發方式沒有相對應的 SDK 或是 third party 可以使用的話呢？ 那麼你就只能一起用 REST API 來完成要做的事情了！
REST API Firebase 提供了五種 Http method
 GET PUT POST PATCH DELETE 其中 GET 和 DELETE 就沒什麼特別好說的，你就是取得一個 JSON 或是刪除一個。  PUT PUT 就和平常使用 PUT 的方式一樣， 它會把整個 JSON 覆蓋成你目前丟上去的 JSON。</description>
    </item>
    
    <item>
      <title>Vapor</title>
      <link>https://example.com/p/vapor/</link>
      <pubDate>Thu, 03 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/vapor/</guid>
      <description>Vapor 在 Swift 開源之後，開發者們便開始將這語言往更多層面去發展，而 web app 便是其中一項。 Vapor 是一款以 Swift 作為主要語言的 Server 建構服務，讓我們可以透過它來開發 Web 相關的應用； 對於 iOS 開發人員而言，Swift 可以用來開發 web app 是一件有趣的事情， 其代表著我們可以使用同一個語言來開發一個產品，從 server 到 client。
安裝方式 不同於在安裝 iOS 第三方套件的流程，Vapor 需要透過 terminal 來安裝相關內容： 首先，得先安裝 Vapor 的 CLI
curl -sL toolbox.qutheory.io | sh 安裝完之後，便可以在 terminal 底下使用 vapor 的指令。
建立新專案 我們可以透過下方的指令，來建立一個新專案：
vapor new ProjectName 其中第三方套件的管理方式，是使用 Swift Package Manager， 所以我們會在目錄下看到一個 Package.swift 和 Package.pins， 這方面倒是有些像 CocoaPods 所使用的 Podfile 的概念。
使用 Xcode 開發 有了專案後，你可以選擇直接打開 main.swift 來進行開發， 但如果比較喜歡使用 Xcode 開啟一個專案，而非單一檔案， 則可以透過下方指令才建立 .</description>
    </item>
    
    <item>
      <title>Fastlane - match</title>
      <link>https://example.com/p/fastlane-match/</link>
      <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/fastlane-match/</guid>
      <description>Fastlane 是什麼？ 簡單來說，它可以替你解決除了寫程式以外的很多事情； 像是「螢幕截圖」、「打包上傳到 Testflight」、「建立 App Store 的 App 資訊」等等， 尤其是在一個專案（project）擁有多個 target 的時候， 更是只需要一行就可以打包出十幾個 App，並且分別上架到 App Store。 而在這篇文章裡頭，會介紹其中一項功能的部分用法：
Match Match 主要負責和 Certificate 相關的處理，這邊所要帶給大家的使用情境是， 一個 iOS 專案同時有需要多人同時開發，我們通常會採取的作法有下列幾種：
在 Apple Developer Team 之中加入專案各個開發人員使用自己的 Apple ID 在 Apple Developer Team 之中加入專案各個開發人員的公司 Apple ID 提供給專案各個開發人員相對應的 Provisioning Profile 第一種和第二種的做法差不多，但其壞處就是管理者無法有效地管理 Certificate， 所以有可能會時常出現一些奇怪的 App IDs 或是 iOS Provisioning Profile， 或是誰又不小心把誰的 certificate revoke ⋯⋯
所以我們需要權限劃分清楚 建議的做法是註冊一組公用的開發者帳號，不和任何人產生連結性
e.g dev@apple.com
只放這組帳號在 Apple Developer Team 裡頭，開發相關的處理皆由這組帳號來負責， 而帳號密碼無需流通到僅負責開發的人員手中； 意思是指，讓單純寫 Code 開發的人員，無須註冊特別的 Apple ID 或是加入哪個 Team， 只需要透過 fastlane match 的方式來獲得 Certificate，可以開發就好！</description>
    </item>
    
    <item>
      <title>Socket</title>
      <link>https://example.com/p/socket/</link>
      <pubDate>Sat, 15 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/socket/</guid>
      <description>最近在接觸即時通訊相關的開發內容，撇除使用第三方服務的串接， 大多數都是建議使用 Socket 來和伺服器端進行連接和溝通。 而研究了一下，在 TCP / IP 架構下，sockets 可以分為兩種
 Datagram sockets(connectionless) Stream sockets(connection-oriented)  Datagram sockets(connectionless) Datagram sockets 是使用 UDP 封包來進行傳送， 其主要的特色是速度快但不能保證資料的完整性以及次序有可能會有誤； 所以大多是使用在廣播資訊或是傳送一些較不是那麼重要的內容。
Stream sockets(connection-oriented) 而 Stream sockets 則是使用 TCP 封包來傳遞， 其因為會先需要確認 Server 和 Client 兩者連接狀態後再傳遞， 故速度較慢一些，但至少能確認資料的有序性以及完整度。
簡單的總結 以中華郵政的觀點來看，以結果來區分的話， 我們可以簡略地將 UDP 視為平信、TCP 視為掛號信。 而即時通訊的部分，依照上述的特色來看，就得選擇使用 TCP 的方式來進行溝通。
Server 和 Client 的溝通流程 首先，伺服器端和用戶端兩者必須使用同一類的封包才能互相通訊， 意思便是指 Server 建立了一個 UDP Socket，Client 也必須使用 UDP Socket 才能兩者打通。 而 Socket name 會需要包含 IP、Port、以及使用哪種協定； 當 Client 端的 Socket 成功聯繫上 Server 端的 Socket 時， 這兩者便形成一組 association。</description>
    </item>
    
    <item>
      <title>多個帳號的 SSH Config 設定</title>
      <link>https://example.com/p/%E5%A4%9A%E5%80%8B%E5%B8%B3%E8%99%9F%E7%9A%84-ssh-config-%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%A4%9A%E5%80%8B%E5%B8%B3%E8%99%9F%E7%9A%84-ssh-config-%E8%A8%AD%E5%AE%9A/</guid>
      <description>一般的情形下，我們不會太需要去做 config 檔案的設定， 因為其實不太需要建立太多組的 SSH key 來增加管理上的麻煩； 但隨著身份的增加（大多數是因為工作關係）， 我們會需要用到其他組 SSH key 來連接 git server。
如果公司使用的 git server，是我原本就沒有使用的呢？ 那就沒什麼差了。 就像是我第一份工作，公司所使用的 git server 為 AWS 的 CodeCommit， 而原先我根本就不用使用到那邊的服務，所以建立一組 SSH key 在 AWS 上使用也沒什麼衝突。 且 AWS 上的教學文件，會讓你在 ~/.ssh/config 之中，以 Host 作為區別； 所以它只會在 AWS 上使用你為了 AWS 所建立的 key。
但⋯最容易發生的情形就是： 公司也使用 Github 作為組織的 git server 通常我們會有一組自己私人的 Github 帳號，若公司不反對你使用私人帳號加入組織的話， 其實你也就沒什麼差了； 但大多數的情形是會給你一組（或是請你申請一組）公司信箱的 Github 帳號， 來維護 private git repository。
Public key 我們先來看看 ssh 的 public key 裡頭，帶了哪些資訊： 重點便是最後的 xpopchi@gmail.</description>
    </item>
    
    <item>
      <title>print</title>
      <link>https://example.com/p/print/</link>
      <pubDate>Fri, 07 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/print/</guid>
      <description>print 在第一次接觸一個沒學過的程式語言時，我們多半可以看到會以「Hello, world!」作為開頭； 而你第一個所使用的 method，也很有可能就是印出東西相關的。 我在這邊寫的是 print，可能在別的語言並不是這個詞，是 printf 或是 console.log() 之類， 但這邊（或是這整個網站XD）就以 Swift 為主。
NSLog v.s print 有接觸過 iOS 開發的人，你可能也會看過別人使用 NSLog，而這邊就解釋一下兩者的差異：
NSLog 它是屬於 Fundation 的一個 function：
會加上 timestamp 會加上 identifier 會印在 device console 會花較多一些些的效能，所以會比較慢一些（因為前兩者）
print 會印在 debugger console 所以，若你只是需要記錄在 debugger console 的話，則建議就使用 print 就好。
開始使用 為了瞭解程式的執行內容，我們便開始在一些地方加上 print 的功能，像是
if a == 1 { print(&amp;#34;a 等於 1&amp;#34;) } else { print(&amp;#34;a 不等於 1&amp;#34;) } 這樣就可以在 debugger console 那看到程式目前是進到哪個判斷式裡頭， 不過他大概就很簡略地顯示
a 等於 1</description>
    </item>
    
    <item>
      <title>Apple Pay</title>
      <link>https://example.com/p/apple-pay/</link>
      <pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/apple-pay/</guid>
      <description>Apple Pay Apple Pay 已經在台灣流通一段時間，第三方支付的相關業者也相接著推出串接的服務； 而撇除串接第三方支付的 SDK， iOS 開發者本身的流程呢？
Apple developer 相關設定 首先，你需要先到 Apple developer &amp;gt; Identifiers &amp;gt; Merchant IDs 註冊一個 Identifier
新建完之後，點擊裡頭的 edit，需要補上 CSR 檔； 而如果你只是要測試這個流程，沒有要走到金流相關的測試的話，可以先跳過這段。
Xcode 相關設定 接著到你的專案裡頭，打開 Apple Pay 的開關並填入剛剛註冊的 Merchant ID。
以及 import PassKit，便可以在專案中使用 Apple Pay！
流程解釋 使用者按下 Apple Pay 的按鈕後，我們該做的流程為
 建立訂單（PKPaymentRequest） 填寫訂單相關內容 建立 Apple Pay 的畫面（PKPaymentAuthorizationViewController） 設定 PKPaymentAuthorizationViewController 的 delegate present Apple Pay 的畫面 而訂單相關內容可以填寫寄送相關（ship）以及聯絡人相關（contact）和金額那些基本的。  func applePay() { let request = PKPaymentRequest() request.merchantIdentifier = &amp;#34;merchant.</description>
    </item>
    
    <item>
      <title>JWT</title>
      <link>https://example.com/p/jwt/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/jwt/</guid>
      <description>JWT JWT（ JSON Web Token）和 iOS 比較有相關聯的地方， 便是在於 APNs p8 是使用 JWT 格式作為傳遞； 而有關於 JWT 的相關資料，可以參考 這個網站。 以之前所提到的 APNs 來說，是由三個部分所組成：
 Header Payload Verify signature  Header 在 APNs 裡頭，需要包含這兩者
alg：所使用的加密方式（algorithm），p8 是使用 ES256 作為加密方式 kid：鑰匙的 ID（key identifier） 例如： alg: ES256 kid: 12345678
Payload iss：所發送的人（issuer），這邊為開發者的 Team ID iat：所發送的時間（issued at）
Verify signature 這邊便是將上述兩者，分別做 base 64 加密後輸出成字串，再加上 p8 的 key， 一起做 ES256 加密後的結果，所以大概長這樣： {header base 64 encode}.{payload base 64 encode}.{ES256 hash[(header base 64 encode).</description>
    </item>
    
    <item>
      <title>Wifi 密碼 – 共享密碼的平台</title>
      <link>https://example.com/p/wifi-%E5%AF%86%E7%A2%BC-%E5%85%B1%E4%BA%AB%E5%AF%86%E7%A2%BC%E7%9A%84%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/wifi-%E5%AF%86%E7%A2%BC-%E5%85%B1%E4%BA%AB%E5%AF%86%E7%A2%BC%E7%9A%84%E5%B9%B3%E5%8F%B0/</guid>
      <description>上週利用一些閒暇時間，串接一些服務寫了這個簡單的小工具， 主要為了解決每次到一間新的店家時，都得先找找 Wifi 的資訊： 找店員問、找菜單上有沒有寫、找牆壁有沒有貼⋯⋯ 於是乎想找一個地方，把我所知道的 Wifi 帳號及密碼記下來， 儘管只要連線過一次，就不會再詢問了，但至少下次人家問我的時候可以告訴他。
使用流程 打開 Wifi 密碼 – 共享密碼的平台 後，會需要使用 Facebook 做登入的動作， 其主要原因是，裡頭的資訊是由全部使用者共同維護的（共筆的概念）， 所以其實會紀錄是哪個使用者新增 Wifi 資訊，但並不會顯示出來。 為了讓使用者承擔一點點微薄的責任，來讓大家都可以比較信任 Wifi 裡頭的資訊可信度， 便加入的登入的系統。
 登入畫面 
接著我們會看到主畫面：
 Wifi 列表 
可以看到目前共筆上，有哪些 Wifi 的資訊：
 名稱 地點 狀態 最後更新時間 點擊進去之後，有可能會跳出 AdMob 的獎勵型影片廣告，可以點擊連結看看當初實作的流程。 看完廣告之後才能進到內容頁面，來觀看 Wifi 密碼。  舉報無效 下方有個按鈕可以點選，便可以更改此 Wifi 資訊的狀態為「不可用」， 而目前版本會在前面的列表之中就直接篩選掉，所以並不會看到不可用的內容。 若是有人一直將你家的 Wifi 貼上來，你一直舉報也無法遏止這行為的話，請麻煩告知我⋯⋯
實作方向 – 登入 臉書的登入參照 Facebook Developer 的相關文件，先建立一個 Facebook 的應用程式； 以及利用 Firebase 的 Auth，裡頭有和 Facebook 結合的文件可以依循著做。</description>
    </item>
    
    <item>
      <title>APNs</title>
      <link>https://example.com/p/apns/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/apns/</guid>
      <description>APNs（ Apple Push Notification service） 相信有在開發 iOS app 的開發者，對於這個詞應該都不會太陌生； 簡單來說，它就是推播的功能。 而推播其實有分成兩種：
 Local notification Remote notification 這兩者的差異就如同名字的一般，前者是本地的通知，後者為遠端的通知。  Local notification 本地推播在 iOS 10 以後，可以參考 UserNotifications 這個 framework。 這邊附上以區域範圍為觸發條件的推播寫法： https://gist.github.com/ArchieR7/85ee0a2d8cdd652d78d6c08eebfd0fae 而鬧鐘那種概念的，或是遊戲提醒（例如遊戲的愛心已經回滿了，趕快回來玩哦！）， 這種以時間作為觸發條件的，則是設定 notification.fireDate，給它一個 Date 便會在那時候觸發。
Remote notification 遠端的推播則是如同聊天軟體常常收到的那種推播（ＯＯＯ傳送貼圖給您！）， 在 AppDelegate.swift 註冊那些的就不寫在這了～ 如果是在公司上班或者和後端合作，寫完註冊推播及回傳 deviceToken 和收到之後要幹嘛的動作， 通常就不會碰到「該如何打推播給 App」的問題，因為 iOS 只需要知道收到該怎辦XD 但總會有需要自己打推播測試、或是開發自己 app 的時候， 這邊就來談談 iOS 開發者該怎麼做！
APNs key 以往我們在產生 APNs key 的時候，是會得到一組有期限的 .p12 檔案， 其中不同的 bundle identifier 會配對到不同的 .p12 檔案； 這是一件蠻麻煩的事情，我們需要管理不同 App 的 APNs key， 上架 20 個有推播功能的 app，就需要維護 20 組 .</description>
    </item>
    
    <item>
      <title>AdMob 獎勵式廣告實作</title>
      <link>https://example.com/p/admob-%E7%8D%8E%E5%8B%B5%E5%BC%8F%E5%BB%A3%E5%91%8A%E5%AF%A6%E4%BD%9C/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/admob-%E7%8D%8E%E5%8B%B5%E5%BC%8F%E5%BB%A3%E5%91%8A%E5%AF%A6%E4%BD%9C/</guid>
      <description>AdMob 在 Google 的廣告投放服務之中，是以 AdSense 作為主軸，整合所有廣告相關的服務； 而 AdMob 則是其中一個專門針對行動裝置的部分。 所以若 iOS 的開發者想在其應用上放置廣告單元，則需要從 AdMob 著手。
建立廣告單元 首先，需要先到 AdMob 的控制台中，新建一個新的應用程式， 並將 app 的相關資訊填寫完整。
再者，則是建立一個廣告單元，而這篇所要分享的是「獎勵式廣告」的實作。
什麼是獎勵式廣告？ 獎勵式廣告的意思就如其名，是一個可以在編輯時設定， 反饋給觀看玩廣告的使用者一些獎勵的一種廣告模式； 如大部分的手機遊戲，觀看影片後可以得到一些鑽石、金幣或者特殊加成等。
設定廣告獎勵 我們可以在這個畫面中，去設定使用者觀看頻率的限制以及獎勵數量。
而在後面程式實作的時候，會講解這邊設定會影響到什麼。
Framework 安裝 你可以透過 CocoaPods 或是直接下載拉進專案之中； 這邊由於我所加入廣告的 App 有整合 Firebase 的相關服務， 而 Firebase 官方並無支援 Carthage，所以在這就一併使用 CocoaPods 來做套件的管理。 因為使用 Firebase，所以只需要在原先的 Podfile 之中加上
pod &amp;#39;Firebase/AdMob&amp;#39; 並且執行 pod install，即可完成安裝。
AppDelegate.swift 先在上方 import GoogleMobileAds，並需要在 FirebaseApp.configure() 之後，加上 AdMob 的廣告設定： GADMobileAds.configure(withApplicationID: Your_Ads_ApplicationID)
import Firebase import GoogleMobileAds func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?</description>
    </item>
    
    <item>
      <title>淺談 Android 的逆向工程</title>
      <link>https://example.com/p/%E6%B7%BA%E8%AB%87-android-%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E6%B7%BA%E8%AB%87-android-%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
      <description>Android？ 是的，這篇正是要寫有關於 Android 的逆向工程，儘管這也很可能是本站唯一一篇XD
起因 看到放在「Hack」的分類上，便可以得知，是因為想要修改遊戲參數而開始涉略⋯⋯ 提到 Android 的遊戲開發方式，我們可以簡單地分為兩種類型：
 以 Java 開發 以 Unity 開發 這篇主要會以 Java 開發的遊戲作為內容分享（因為我想改的遊戲是此類型XD）  先說結論 我目前還沒有修改成功，因為這款遊戲有對 apk 進行混淆的動作⋯⋯
以至於一時之間無法找到我需要的參數來做修改⋯⋯ 不過，就先記錄一下如何走到看得到程式碼這一步！
使用到的工具
 Apk tool dex2jar jd-gui  Apk tool apk tool 主要負責將 .apk 拆開來，在反編譯之後，可以看到一堆 .smali 及 resource 的相關檔案， 也是負責將修改完的檔案重新包回 apk 的工具。 而由於我沒有修改任何 Code，所以只有解出 .smali 和 resource，看看裡頭有什麼東西和圖片影音檔而已。
dex2jar 和 jd-gui dex2jar 的功用在於將 .apk 轉成 .jar，配合 jd-gui 打開 .jar 來探究其 source code 內容是什麼。
流程總結 配合上述的三個工具，大概的流程應該是先以 dex2jar 和 jd.</description>
    </item>
    
    <item>
      <title>開發人員與 UI / UX 設計師之間的合作模式</title>
      <link>https://example.com/p/%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E8%88%87-ui-/-ux-%E8%A8%AD%E8%A8%88%E5%B8%AB%E4%B9%8B%E9%96%93%E7%9A%84%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E8%88%87-ui-/-ux-%E8%A8%AD%E8%A8%88%E5%B8%AB%E4%B9%8B%E9%96%93%E7%9A%84%E5%90%88%E4%BD%9C%E6%A8%A1%E5%BC%8F/</guid>
      <description>UI / UX 設計師 在工作了一段時間後，陸續接觸了幾位不同的 UI / UX 設計師， 而每個人做事的方法都有所差異，在這邊簡單地列出幾個想法。
設計師所使用的工具 在 UX 設計師裏頭，有配合過使用 Axure、Adobe Xd、或是用 Sketch 直接和 UI 一起出的。 而在 Sketch 的模式下，它裡頭有個詞叫做「symbol」，其意義和 iOS 裡頭的 UIView 相關物件相同。
物件的概念 Sketch 提供了 Symbol 的建立，讓使用者在設計時，能夠把一些重複使用到的元件，做成一個 symbol， 而它會自動定義這個 symbol 哪些值是可以被異動的：
如同上方寫的「中華電信」，便是可被異動的值，但更改這個字串並不會影響整體的外觀。
以 iOS developer 來說 設計師可以了解到，UINavigationBar 的樣貌大概是長這樣，並明白 UIBarButtonItem 能夠控制的外觀欄位有哪些，像是這邊顯示的 Edit 字串。 而設計師也可以自行建構 symbol，來增加重複使用的便利性；這點也如同我們在開發 App 一樣， 會建立一些較容易重複使用到的 UIView 來呈現畫面。 設計師可以更明確地定義物件哪些欄位是會怎麼變動的，像是一個「客製化的按鈕」， 可以先明白它的背景色可能會在其他頁面做換色、或是字體會更改， 這都可以讓開發人員在一開始設計這個按鈕時，都考慮進去來增加彈性。
維持一致性 symbol 的概念，可以維持整個專案的外觀一致性； 也就是說當設計師需要調整剛剛所說的「客製化按鈕」， 想把圓角從 5 pixel 改為 10 pixel，便只需要更改 symbol 即可， 不需要再到各個使用到相同外觀的按鈕，都去一一調整為 10 pixel； developer 也一樣，只需要更改其類別即可，省去重複定義的時間。 也可降低設計師和開發人員之間的溝通成本，讓彼此能夠更專注地做好自己的工作。</description>
    </item>
    
    <item>
      <title>Unit test with async functions</title>
      <link>https://example.com/p/unit-test-with-async-functions/</link>
      <pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/unit-test-with-async-functions/</guid>
      <description>iOS Unit test 在寫 Unit test 的時候，有時候會遇到要測試的 function 是 async 的， 但在 Unit test 的 function 之中，它本身就是走單一 thread 來決定測試結果； 若沒有多做其他處理，closure 或是其他 thread 做的事情，便不會反應到結果上。 所以我們需要告知 Unit test，要等待一下我們要測的內容。
func testAsyncFunction() { let exp = expectation(description: &amp;#34;Async Expectation&amp;#34;) NetworkManager.shared.update(data: Data(), completeHandler: { exp.fulfill() }) waitForExpectations(timeout: 30, handler: nil) } 建立一個 expectation，並在 closure 裏頭執行一些測試結果判斷， 判斷完後，補上 exp.fulfill() 來告知 waitForExpectations 可以結束等待。 這樣就可以做 async functions 的 Unit test 了！</description>
    </item>
    
    <item>
      <title>dismiss function</title>
      <link>https://example.com/p/dismiss-function/</link>
      <pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/dismiss-function/</guid>
      <description>dismiss(animated:completion:) 這個 method 對於大家而言，應該都不陌生； UIViewController 可以呼叫這個 method 來關閉，而它所關閉的概念如下： UINavigationController
 UIViewController1 UIViewController2 UIViewController3  不論現在 presentingViewController 是 UIViewController 1、2、或者是 3， 在這三者呼叫 dismiss(animated:completion:) 時， 都會把 UINavigationController 的所有 viewControllers 都 dismiss。 然而一個很常的使用方式是，我們會在 UIViewController 的物件之中，自行呼叫 dismiss：
dismiss(animated: true, completion: nil) 不過這麼做的話，執行 present(, animated: , completion: ) 的 UIViewController， 就不會知道是在哪個流程或是哪個畫面 dismiss 的。 比較好的做法是，會被 present 的 UIViewController 都能透過 delegate 的方式， 告知原本的 UIViewController 「我按下了什麼按鈕」， 再由前面的 UIViewController 來決定是否 dismiss 或是做其他事。
讓整體的流程能夠得到比較好的控制，也讓 UIViewController 彼此之間的關係有個清楚的釐清。</description>
    </item>
    
    <item>
      <title>網域相關設定</title>
      <link>https://example.com/p/%E7%B6%B2%E5%9F%9F%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/</link>
      <pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E7%B6%B2%E5%9F%9F%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/</guid>
      <description>昨天，終於在 PChome 購買到 www.Archie.tw 來和大家分享一下這段經歷。 首先，從要建設這個網站的時候，就已經打算購買 Archie.tw 的網域名稱； 一來，讓人方便和我本身聯想在一塊， 二來，是為了解決這個問題：
通常在 Organization Identifier 會建議填上倒裝的網址，如 com.facebook、com.google 之類的， 而我之前私人所寫的 App，多半是隨便打⋯⋯（因為那時候沒有一個依循的地方）。
不過，當初在 PChome 要點購買時，發現其實這是有人註冊走的⋯⋯ 但還好，它的期限剛好最近會到期（2017-05-12）。 想當然耳，我便是在等到 5 月 12 日時，馬上前往去註冊，深怕自己錯過！ 只是上頭的文字依舊是 2017-05-12 過期，並且還是之前那個人的相關資訊， 意思就是說其實網域是還沒被釋放出來的⋯⋯
於是便去查詢了相關的資訊，原來網域到期後，會有一段贖回期和釋放期， 原先註冊的人可以在那段時間贖回其網域； 以 .tw 來說，贖回期為 30 天、刪除期為 3 天， 於是乎 2017-05-12 到期的這個網域，其實我得等到 33 天後的 2017-06-14 才能註冊。
而就在昨日（2017-06-14）中午時，再更新一次購買的網頁，便發現可以註冊了！ 費用為 800 元 / 一年，透過線上刷卡的方式解決了這一個多月來的網域問題！ 等付款過後的一、兩個小時內，便可以設定 DNS，將原先 vultr 上的 IP 設定進去， 就可以透過 Archie.tw 連到 vultr 的機器了～
另外，vultr 以及 WordPress 都需要做相關的設定，將原先顯示 IP 的地方， 都更改為剛剛獲得的網域名稱，並順道設定 https 的問題。</description>
    </item>
    
    <item>
      <title>KVOController</title>
      <link>https://example.com/p/kvocontroller/</link>
      <pubDate>Tue, 06 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/kvocontroller/</guid>
      <description>KVOController 有關 Observe 的相關做法，在 Swift 上我會選擇使用 RxSwift，那 Objective-C 呢？ 在這邊簡單介紹一下 KVOController 的 solution 給 Objective-C 的開發者。 在 NSObject 的子類別下，都會繼承到一個 FBKVOController 的物件，名字為 KVOController； 而這邊要使用的 method 是這個：
(void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block; object 是我們要觀察的物件 keyPath 是 object 底下的要觀察的值，它的名稱（key） options 則是填入 NSKeyValueObservingOptions block 再來決定當 object 的 keyPath 那物件有更動時，要做些什麼事
舉個例子 [self.KVOController observe:self keyPath:NSStringFromSelector(@selector(observeObjectName)) options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&amp;lt;NSString *,id&amp;gt; * _Nonnull change) { //do something }];  observe:self keyPath:NSStringFromSelector(@selector(observeObjectName))  翻成白話文就是 self 去觀察 self.</description>
    </item>
    
    <item>
      <title>Optional</title>
      <link>https://example.com/p/optional/</link>
      <pubDate>Tue, 23 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/optional/</guid>
      <description>前言 Optional 正如其名，就是個可選擇或者說是可有可無的意思。
Optional 在 Swift 的開發過程之中，我們可以看到「 ! 」、「 ? 」存在於變數之後，像是 var userName: String? 正式意味著 userName 這個 String 有可能是 nil。 有關 Swift optional 的解釋和 nil 對於 Swift 的介紹可以看看這篇，由小草哥所攥寫的文章。 這邊要補充的是，在 Objective-C 裏頭，則是使用 nonnull 和 nullable 來代表著 Swift 裡頭的「 ! 」、「 ? 」。 而在 Objective-C 之中，可以使用 NS_ASSUME_NONNULL_BEGIN 及 NS_ASSUME_NONNULL_END 來作為區域性的宣告 @property 的屬性為 nonnull；若其中有需要宣告成 nullable 的，則再補上即可。
NS_ASSUME_NONNULL_BEGIN @interface DemoObject : NSObject @property (nonatomic) NSString *name; @property (nonatomic, nullable) NSString *address; @property (nonatomic, readonly) NSString *phoneNumber; @end NS_ASSUME_NONNULL_END </description>
    </item>
    
    <item>
      <title>七天學會設計模式 - Facade</title>
      <link>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-facade/</link>
      <pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-facade/</guid>
      <description>Facade 其實 Facade 的概念簡單來說，就是簡化使用物件方的介面。 舉個例來說，我建立了一個 Calendar 的 UICollectionView，可能裡頭會需要很多的邏輯判斷；像是「計算 Cell 的 Size」、「判斷日期是否為假日」、「判斷月份」⋯⋯等，但使用這個物件的人，基本上不需要（也不應該）去煩惱這些事情。 如同我們吹電風扇，只需要「強、中、弱、關」的使用介面，並不需要知道它內部是調整不同的功率去達到這效果，但對使用者而言並不是那麼的重要。 而在 MVC 的架構底下便是如此，使用者只需要 ViewController 上可以操作的 function 即可，底部的 Model 是如何操作以及邏輯運算如何，就相對的沒那麼重要，丟給系統去做就好！ 所以在 Facade 的設計模式下，每個物件的介面需要被規劃過，哪些需要使用 private、fileprivate、class 等，適時地分配各個變數或常數及方法的使用權限。</description>
    </item>
    
    <item>
      <title>七天學會設計模式 – Observe</title>
      <link>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-observe/</link>
      <pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-observe/</guid>
      <description>訂閱 有使用過網誌或是一些新聞類型的網站時，通常可以在旁邊看到「訂閱」的按鈕，接著點擊下去後就可以在作者有發動或異動文章時，收到通知。
Observe 這個設計模式的概念類似於「訂閱」的功能，我們會去「訂閱」某個物件，當它做了某些事情或者其值改變時，可以去做相對應的動作。
應用 舉個比較常會遇到的案例：鍵盤 我們通常會希望在鍵盤升起來時，調整我們的畫面，看是移動 View 的 frame，或是設定 TableView 的 ContentOffset 之類的。 而大多數採取的方式是「監聽」 NotificationCenter 的「鍵盤升起」的事件，所以當「鍵盤升起」時，我們可以做相對應的處理；而當「鍵盤收起」時，我們也可以執行另一段 function。 這，便是 Observe 的設計模式。 我們去「訂閱」或者「監聽」某個事件，像是 Value changed 或是某個 function 被呼叫，來做相對應的處理。
第三方套件 RxSwift、ReactiveCocoa 便都是圍繞在 Observe 設計模式的框架，來做響應式的開發。
響應式開發 如名稱所述，意思是指當 Model 或者 ViewModel 的狀態（值）更動時，畫面可以很即時地跟著變動。 對 RxSwift 有興趣的人，可以看看這篇文章 線上讀書會 RxSwift 分享。</description>
    </item>
    
    <item>
      <title>Weak</title>
      <link>https://example.com/p/weak/</link>
      <pubDate>Fri, 05 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/weak/</guid>
      <description>在 iOS 的開發語言之中，不論是 Objective-C 或者 Swift，你或許都有看過這個詞
weak 你可能會知道它可以避免 retain cycle，但其背後的觀念是什麼？
ARC 在目前大家所熟悉的開發環境之中，記憶體的管理是由 iOS 或 macOS 自行去解決的；它會在你宣告或者呼叫物件的時候，替它在計數器上 +1，而當你用不到時，便會 -1。 當計數器為零的時候，便釋放掉這個物件的記憶體位置。 舉個例子，我在某個 ViewController 裏頭，宣告了一個變數 A 及執行一個異步的閉包（closure），並在裡頭使用到 A。 此時，A 在剛剛宣告產生的時候，計數器會是 +1，而在閉包內被使用到，故計數器會再 +1，所以在閉包執行時，它會是 2。
那如果我們這時候，離開了 ViewController，照理說其裡頭的 instance 應該都要被釋放記憶體位置；但因為異步閉包的關係，我們無法確定在離開的時候，異步閉包是否在其他執行緒中正在執行，造成 A 的計數器仍為 1，且會繼續執行異步閉包的內容。
weak 簡單來說就是，它並不會讓這個物件在計數器上 +1，並且在記憶體被釋放之後，指標會指向 nil；而在 Objective-C 及 Swift 裏頭，nil 的物件呼叫方法時，是不會造成崩潰的。
retain cycle 就像是 A 使用到 B，並且 B 也使用到 A，兩者互相幫對方在計數器上 +1，那僅管我們今天離開了這個畫面，系統幫 A – 1 之後，仍然會因為 B 有使用到它，故釋放不掉 A，而 A 有使用 B，所以 B 也釋放不掉。（很饒舌，我知道） 所以在 A 裡頭使用到 B 時，將 B 宣告成 weak B，便不會幫 B 在計數器上記上一筆；當 A 要被釋放掉的時候，也不會因為 B 使用 A，而釋放不掉。</description>
    </item>
    
    <item>
      <title>502 Bad Gateway Error with nginx</title>
      <link>https://example.com/p/502-bad-gateway-error-with-nginx/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/502-bad-gateway-error-with-nginx/</guid>
      <description>源頭 在攥寫七天學會設計模式 – Singleton時，發生了點小狀況。 我點擊 WordPress 的「全部文章」時，顯示 502 Bad Gateway 的錯誤訊息； 由於點下去後不久（一、兩秒內）就跳轉出錯誤，故猜測不是 timeout 的關係， 便開始了一段 debug 的故事⋯⋯
環境 我是使用 WordPress（不是重點）的框架，並架設在 Vultr 的主機上； 主機的主要規格為 CPU 1 vCore、RAM 1024 MB、25 GB SSD。
原因 透過 nginx 的 error log（cat /var/log/nginx/wordpress_https_error.log）， 發現關鍵字： upstream sent too big header while reading response header from upstream 拿去餵狗的結果是，需要調整 nginx.conf（vim /etc/nginx/nginx.conf）， 加上
http { proxy_buffer_size 128k; proxy_buffers 4 256k; proxy_busy_buffers_size 256k; fastcgi_buffer_size 128k; fastcgi_buffers 4 256k; fastcgi_busy_buffers_size 128k; ... } 來調整 buffer size，來避免資源不足直接捨棄的情況（502）。 由於 5 塊美金的方案，Vultr 僅提供 1024 MB 的記憶體大小，但它有 25 GB 的 SSD！ 故可以透過 Swap 的方式，用硬碟換取記憶體的效能。</description>
    </item>
    
    <item>
      <title>工作一年半的一些心得分享</title>
      <link>https://example.com/p/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</link>
      <pubDate>Mon, 24 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</guid>
      <description>前言 前陣子在 PTT MacDev 版寫了篇心得，這邊就轉載過來
正文開始 各位好，這篇文章主要是給新手一些方向和想法～ 純屬個人的經歷和看法，可以一起以輕鬆的態度聊聊～ 我個人是在 2015 年中開始接觸 iOS 的開發，以 Objective-C 為一開始自學方向。 從簡單遊戲開始下手，像是猜數字、圈圈叉叉之類的， 練練基本的拉拉 UI、認識Storyboard、.h 的宣告、.m 的實作等。 接著剛好 Xcode 7 開始讓免費的開發者可以裝 App 至實體裝置上， 發現自己原本都用 4.7 吋的模擬器執行，而到了 5.7 吋的裝置上時， 會有跑版的問題，於是花了一些時間學習 AutoLayout。 而基本上 AutoLayout 有個概念熟悉即可， 除非是比較特別的效果需要思考一下彼此之間的 priority， 不然一般 App 都還蠻輕易解決這方面的問題； 而比較有趣的是，像在 ScrollView 裏頭做 AutoLayout 時， 要有 contentSize 的概念，而不要輕易的點「讓系統補完 constraints」的按鈕。
接著，在我準備面試前的一兩個月，加入了一些 iOS 的開發社群 （e.g iOS @ Taipei、Cocoaheads Taipei等） 厚著臉皮加了版上比較活躍的幾位前輩，並詢問他們一些問題和方向， 於是開始練習其他實作：
氣象資料開放平臺： 練習接 Api，當時我是寫了一個去接目前各雨量觀測站的 App， 篩選 10 分鐘內有偵測到雨量的， 並在 MapView 上放上大頭針，顯示當區目前雨量。 （AFNetworking、MapKit）</description>
    </item>
    
    <item>
      <title>線上讀書會 RxSwift 分享</title>
      <link>https://example.com/p/%E7%B7%9A%E4%B8%8A%E8%AE%80%E6%9B%B8%E6%9C%83-rxswift-%E5%88%86%E4%BA%AB/</link>
      <pubDate>Thu, 23 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E7%B7%9A%E4%B8%8A%E8%AE%80%E6%9B%B8%E6%9C%83-rxswift-%E5%88%86%E4%BA%AB/</guid>
      <description>線上讀書會 RxSwift 分享</description>
    </item>
    
    <item>
      <title>七天學會設計模式 - Singleton</title>
      <link>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-singleton/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/p/%E4%B8%83%E5%A4%A9%E5%AD%B8%E6%9C%83%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-singleton/</guid>
      <description>前言 最近和同事一起購入七天學會設計模式，不過書中是以 Java 作為示範語言； 而這邊，我會以 Swift 及 Objective-C 來攥寫範例並補充些內容。
Singleton 如同它的命名一般，在整個 App 運作時，僅會有一個 instance。
Swift Swift 宣告 Singleton 的方式很簡單，就是在 class 底下宣告一個 static 的常數（constant）。
class SingletonDemo { static let shared = SingletonDemo() } Objective-C 而 Objective-C 底下，我們要注意一些事情； 在 Multi-Thread 的情況下，我們得避免同時有多個 thread 執行建立 instance，故在創建時，必須使用 dispatch_once_t 來確保僅會有一個 thread 執行。
#import &amp;lt;UIKit/UIKit.h&amp;gt; @interface SingletonDemo : NSObject + (instancetype)shared; @end #import &amp;#34;SingletonDemo.h&amp;#34; @implementation SingletonDemo + (instancetype)shared { static SingletonDemo *instance = nil; static dispatch_once_t once_token; dispatch_once(&amp;amp;once_token, ^{ instance = [[SingletonDemo alloc] init]; }); return instance; } @end 學會了如何創建 Singleton 之後，可以想想哪些物件適合以這種方式創建； 如「目前登入的使用者」，正是可以用 Singleton 的方式做設計，畢竟一個 App 同時僅能有一位使用者登入，是大多數軟體的設計，而這恰巧符合 Singleton 的精神。</description>
    </item>
    
  </channel>
</rss>
